<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>可爱连连看乐园</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --tile-font-size: 26px; /* 会被JS动态修改 */
            --cute-blue: #89CFF0;
            --cute-pink: #FFB6C1;
            --cute-green: #90EE90;
            --cute-yellow: #FFFACD;
            --cute-purple: #E6E6FA;
            --text-dark: #4A5568;
            --text-medium: #718096;
            --locked-color: #CBD5E0;
            --star-filled-color: #FFD700;
            --star-empty-color: #E2E8F0;
            --button-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --button-hover-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        body {
            font-family: 'Nunito', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            transition: background 0.5s ease-in-out;
            overflow-x: hidden; /* 防止水平滚动 */
            background: linear-gradient(135deg, var(--cute-pink) 0%, var(--cute-blue) 100%);
        }
        #mainMenuContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 15px;
            width: 100%;
            min-height: 80vh;
        }
        .main-title {
            font-size: 2.8rem;
            color: white;
            text-shadow: 2px 2px 5px rgba(0,0,0,0.25);
            margin-bottom: 30px;
            font-weight: 900;
            letter-spacing: -0.02em;
            line-height: 1.1;
        }
        #initialStartGameButton {
            padding: 15px 35px;
            font-size: 1.5rem;
            font-weight: 800;
            color: var(--text-dark);
            background-color: var(--cute-green);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.25s cubic-bezier(0.175, 0.885, 0.32, 1.275), box-shadow 0.25s ease;
            box-shadow: var(--button-shadow);
        }
        #initialStartGameButton:hover {
            transform: scale(1.08) rotate(-2deg);
            box-shadow: var(--button-hover-shadow);
            background-color: #A9F5A9;
        }

        .level-select-title {
            font-size: 2rem;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            margin-bottom: 20px;
            font-weight: 800;
        }
        #levelListContainer {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 10px;
            width: 100%;
            max-width: 95vw;
        }
        .level-button {
            padding: 10px 12px;
            font-size: 0.9rem;
            font-weight: 700;
            color: var(--text-dark);
            background-color: var(--cute-yellow);
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 15px;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease;
            box-shadow: var(--button-shadow);
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .level-button:hover:not(:disabled) {
            transform: translateY(-2px) scale(1.02);
            box-shadow: var(--button-hover-shadow);
            background-color: #fff7d6;
        }
        .level-button:disabled {
            background-color: var(--locked-color);
            color: #e2e8f0;
            cursor: not-allowed;
            opacity: 0.7;
            border-color: rgba(0,0,0,0.1);
        }
         .level-button .level-name {
            font-size:0.75em;
            color: var(--text-medium);
            margin-top: 3px;
        }
        .level-button .stars-display {
            font-size: 1em;
            margin-top: 5px;
            line-height: 1;
        }
        .level-button .stars-display .star-filled { color: var(--star-filled-color); }
        .level-button .stars-display .star-empty { color: var(--star-empty-color); }
         .level-button .lock-icon {
            margin-left: 6px;
            font-size: 0.8em;
        }

        .game-wrapper {
            display: none;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }
        .game-container { /* 游戏区域主容器 */
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px; /* 移动端内边距减小 */
            background-color: rgba(255, 255, 255, 0.92);
            backdrop-filter: blur(8px);
            border-radius: 20px;
            box-shadow: 0 6px 15px rgba(0,0,0,0.1);
            width: 95vw; /* 容器宽度 */
            max-width: 98vw;
            border: 1px solid rgba(255,255,255,0.25);
            margin: 10px 0;
            box-sizing: border-box; /* 确保padding和border不增加总宽度 */
        }
        .game-title {
            font-size: 1.4rem; /* 移动端标题稍小 */
            font-weight: 800;
            margin-bottom: 8px; /* 减小间距 */
            color: var(--text-dark);
            text-align: center;
        }
        .info-panel {
            display: flex;
            flex-direction: row; 
            flex-wrap: wrap; 
            justify-content: center; 
            align-items: center;
            gap: 5px; 
            width: 100%;
            margin-bottom: 8px; 
            font-weight: 600;
        }
        .info-panel span {
            padding: 4px 6px; 
            background-color: var(--cute-yellow);
            border-radius: 6px; 
            text-align: center;
            color: var(--text-dark);
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            margin: 2px;
            font-size: 0.75rem; 
            min-width: auto; 
            flex-shrink: 0; 
        }
         #errorsDisplay {
            color: #ef4444;
        }

        .board-area { 
            position: relative;
            width: 100%; 
            display: flex;
            justify-content: center;
            margin-bottom: 8px; 
        }

        .game-board { 
            display: grid;
            border: 2px solid var(--cute-purple); 
            border-radius: 10px; 
            background-color: rgba(255, 255, 255, 0.7);
            position: relative;
            z-index: 1;
            box-sizing: border-box; 
        }
        #pathCanvas {
            position: absolute;
            pointer-events: none;
            z-index: 2;
        }

        .tile {
            background-color: var(--cute-purple);
            border: 1px solid rgba(0,0,0,0.05);
            border-radius: 6px; 
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: var(--tile-font-size); 
            cursor: pointer;
            transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1),
                        background-color 0.15s ease,
                        box-shadow 0.2s ease;
            box-shadow: 0 2px 3px rgba(0,0,0,0.08);
            width: 100%; 
            height: 100%;
            box-sizing: border-box;
            overflow: hidden; 
            text-align: center; 
            line-height: 1; 
        }
        .tile:not(.selected):not(.empty):not(.cleared):hover {
            background-color: var(--cute-pink);
            transform: translateY(-1px) scale(1.02);
            box-shadow: 0 3px 6px rgba(0,0,0,0.1);
        }
        .tile.selected {
            background-color: var(--cute-green);
            border-color: #76D7C4;
            color: var(--text-dark);
            transform: scale(1.08);
            box-shadow: 0 0 10px var(--cute-green), 0 0 4px var(--cute-green);
        }
        .tile.hint-highlight {
            background-color: #FFD700 !important;
            border-color: #FFC400 !important;
            box-shadow: 0 0 12px #FFD700, 0 0 6px #FFC400 !important;
            transform: scale(1.1) !important;
        }
        .tile.empty {
            background-color: transparent !important;
            border: none !important;
            box-shadow: none !important;
            cursor: default;
        }
        .tile.cleared {
            transform: scale(0.3) rotate(20deg) translateY(-20px);
            opacity: 0;
            cursor: default;
            pointer-events: none;
            transition: transform 0.4s cubic-bezier(0.68, -0.55, 0.27, 1.55), opacity 0.3s ease;
        }
        .controls {
            margin-top: 10px; 
            display: flex;
            flex-wrap: nowrap;
            justify-content: space-around; 
            gap: 8px; 
            width: 100%;
            max-width: 320px; 
        }
        .btn.icon-btn {
            padding: 8px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 1.1rem;
        }
        .btn.icon-btn svg {
            margin-right: 0;
            width: 1.3em;
            height: 1.3em;
        }

        .btn {
            padding: 8px 15px;
            font-size: 0.85rem;
            font-weight: 700;
            color: white;
            background-color: var(--cute-blue);
            border: none;
            border-radius: 20px;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease, background-color 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--button-shadow);
            text-shadow: 1px 1px 1px rgba(0,0,0,0.1);
        }
        .btn svg {
            width: 1em;
            height: 1em;
            margin-right: 0.4em;
        }
        .btn:hover {
            transform: translateY(-1px) scale(1.02);
            box-shadow: var(--button-hover-shadow);
        }
        .btn:active {
            transform: translateY(0px) scale(0.98);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .btn.bg-green-500 { background-color: var(--cute-green); color: var(--text-dark); }
        .btn.bg-green-500:hover { background-color: #A9F5A9; }
        .btn.bg-yellow-500 { background-color: #FFD700; color: var(--text-dark); }
        .btn.bg-yellow-500:hover { background-color: #FFDB58; }

        #message-box {
            position: fixed;
            top: 15px;
            left: 50%;
            transform: translateX(-50%) translateY(-60px);
            color: var(--text-dark);
            padding: 10px 18px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.15);
            z-index: 1000;
            opacity: 0;
            font-size: 0.95rem;
            font-weight: 600;
            transition: opacity 0.3s ease, transform 0.35s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            display: none;
            text-align: center;
        }
        #message-box.success { background-color: var(--cute-green); }
        #message-box.error { background-color: #FFC0CB; }
        #message-box.win { background-color: #FFD700; }
        #message-box.info { background-color: var(--cute-blue); color: white; }
        #message-box.gameover { background-color: #B0C4DE; }
        #message-box.show {
            display: block;
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        .modal-overlay.show {
            display: flex;
            opacity: 1;
        }
        .modal-content {
            background-color: white;
            padding: 25px 30px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            text-align: center;
            max-width: 85vw;
            width: 350px;
            transform: scale(0.9);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .modal-overlay.show .modal-content {
            transform: scale(1);
        }
        .modal-content h2 {
            font-size: 1.8rem;
            font-weight: 800;
            color: var(--text-dark);
            margin-bottom: 12px;
        }
        .modal-content p {
            font-size: 1rem;
            color: var(--text-medium);
            margin-bottom: 20px;
            line-height: 1.5;
        }
        .modal-buttons {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        .modal-buttons .btn {
            min-width: 140px;
            width: 100%;
            max-width: 200px;
            font-size: 0.9rem;
            padding: 10px 15px;
        }


        @media (min-width: 640px) { 
            .game-container { padding: 20px; }
            .game-title { font-size: 1.8rem; margin-bottom: 15px;} 
            .info-panel {
                gap: 10px; 
                margin-bottom: 15px;
            }
            .info-panel span {
                padding: 5px 10px;
                font-size: 0.9rem; 
            }
            .board-area { margin-bottom: 15px; }
            .controls { margin-top: 20px; gap: 15px; max-width: 400px; }
            .btn.icon-btn { width: 45px; height: 45px; } 
            .btn.icon-btn svg { width: 1.4em; height: 1.4em;}

            .main-title { font-size: 4rem; margin-bottom: 50px;}
            #initialStartGameButton { font-size: 2rem; padding: 22px 50px;}
            .level-select-title { font-size: 2.8rem; }
            .level-button { font-size: 1.2rem; padding: 18px 25px; }
            #message-box { font-size: 1.2rem; padding: 20px 30px; }
            .modal-content { width: 450px; padding: 35px 50px;}
            .modal-content h2 { font-size: 2.2rem; }
            .modal-content p { font-size: 1.2rem; }
            .modal-buttons {
                flex-direction: row;
                justify-content: center;
                gap: 15px;
                flex-wrap: wrap;
            }
            .modal-buttons .btn { width: auto; }
        }
         @media (min-width: 768px) { 
             .game-container { padding: 25px; max-width: 700px; }
             #levelListContainer { max-width: 700px; }
             .btn.icon-btn { width: 50px; height: 50px; }
             .btn.icon-btn svg { width: 1.5em; height: 1.5em;}
        }
    </style>
</head>
<body>
    <div id="mainMenuContainer">
        </div>

    <div class="game-wrapper">
        <div class="game-container">
            <h1 class="game-title" id="levelTitle">加油！连起来！</h1>
            <div class="info-panel">
                <span id="timer">时间: 00:00</span>
                <span id="score">得分: 0</span>
                <span id="hints">提示: 3</span>
                <span id="errorsDisplay">错误: 0/0</span>
            </div>

            <div class="board-area">
                <div id="gameBoard" class="game-board">
                    </div>
                <canvas id="pathCanvas"></canvas>
            </div>

            <div class="controls">
                <button id="restartButton" class="btn icon-btn" title="重玩本关">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0 3.181 3.183a8.25 8.25 0 0 0 13.803-3.7M4.031 9.865a8.25 8.25 0 0 1 13.803-3.7l3.181 3.182m0-4.991v4.99" />
                    </svg>
                </button>
                <button id="shuffleButton" class="btn icon-btn bg-green-500" title="洗牌牌">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M7.5 21 3 16.5m0 0L7.5 12M3 16.5h13.5m0-13.5L21 7.5m0 0L16.5 12M21 7.5H7.5" />
                    </svg>
                </button>
                <button id="hintButton" class="btn icon-btn bg-yellow-500" title="小提示">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M12 18v-5.25m0 0a6.01 6.01 0 0 0 1.5-.189m-1.5.189a6.01 6.01 0 0 1-1.5-.189m3.75 7.478a12.06 12.06 0 0 1-4.5 0m3.75 2.354a15.054 15.054 0 0 1-4.5 0M3.75 10.5h.008v.008H3.75V10.5Zm0 3.75h.008v.008H3.75V14.25Zm0 3.75h.008v.008H3.75V18Zm16.5-3.75h.008v.008H20.25V14.25Zm0 3.75h.008v.008H20.25V18Zm0 3.75h.008v.008H20.25V21.75Zm-3.75-11.25h.008v.008H16.5V10.5Zm0 3.75h.008v.008H16.5V14.25Zm0 3.75h.008v.008H16.5V18Z" />
                    </svg>
                </button>
                 <button id="levelSelectButton" class="btn icon-btn" style="background-color: var(--cute-purple); color: var(--text-dark);" title="关卡选择">
                     <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"> <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 5.25h16.5m-16.5 4.5h16.5m-16.5 4.5h16.5m-16.5 4.5h16.5" /> </svg>
                </button>
            </div>
        </div>
    </div>

    <div id="message-box"></div>
    <div id="endGameModalOverlay" class="modal-overlay"></div>

    <script>
        // DOM Elements
        const mainMenuContainer = document.getElementById('mainMenuContainer');
        const gameWrapper = document.querySelector('.game-wrapper');
        const levelTitleElement = document.getElementById('levelTitle');
        const gameBoardElement = document.getElementById('gameBoard');
        const pathCanvas = document.getElementById('pathCanvas');
        const pathCtx = pathCanvas.getContext('2d');
        const restartButton = document.getElementById('restartButton');
        const shuffleButton = document.getElementById('shuffleButton');
        const hintButton = document.getElementById('hintButton');
        const levelSelectButton = document.getElementById('levelSelectButton');
        const timerDisplay = document.getElementById('timer');
        const scoreDisplay = document.getElementById('score');
        const hintsDisplay = document.getElementById('hints');
        const errorsDisplay = document.getElementById('errorsDisplay');
        const messageBox = document.getElementById('message-box');
        const controls = document.querySelector('.controls');

        // --- Emoji Icon Sets for Themes ---
        const EMOJI_SETS = {
            faces: ['😀', '😂', '😊', '😍', '🤔', '😎', '👻', '👽', '👾', '🤖', '🎃', '🤡', '🥳', '🥺', '🤩', '😱', '😴', '🥴', '🤧', '🤠'],
            fruits: ['🍓', '�', '🍎', '🍊', '🍇', '🍍', '🥝', '🥭', '🍑', '🍒', '🍌', '🥥', '🥑', '🍈', '🫐', '🍐', '🍋', '🌶️', '🌽', '🥕'],
            animals: ['🦊', '🐻', '🐼', '🐨', '🐯', '🦁', '🐮', '🐷', '🐸', '🐙', '🐵', '🦄', '🐔', '🐧', '🦉', '🦋', '🐌', '🐞', '🐢', '🐬'],
            objects: ['⚽', '🏀', '🏈', '🎱', '🎁', '🎈', '🎉', '🎄', '💡', '💻', '📱', '⏰', '💎', '🔔', '🔑', '👑', '☂️', '🎨', '📚', '✏️'],
            sweets: ['🍰', '🧁', '🍩', '🍪', '🍬', '🍭', '🍫', '🍦', '🍧', '🍮', '🍯', '🥧', '🥨', '🧇', '🍡', '🥮', '🥠', '🍥', '🧋', '🥤'],
            vehicles: ['🚗', '🚕', '🚙', '🚌', '🚎', '🏎️', '🚓', '🚑', '🚒', '🚐', '🚚', '🚛', '🚜', '🛵', '🚲', '✈️', '🚀', '🛸', '🚁', '⛵️'],
            music: ['🎸', '🎺', '🎷', '🎻', '🎹', '🥁', '🎤', '🎧', '🎼', '🎵', '🎶', '🪕', '🪗', '🪘', '🎻', '🎺', '🥁', '🎷', '🎹', '🎤'],
            weather: ['☀️', '🌙', '⭐', '☁️', '⛅', '⛈️', '🌤️', '🌥️', '🌦️', '🌧️', '🌨️', '🌩️', '🌪️', '🌫️', '🌬️', '🌈', '❄️', '☃️', '⛄', '🌡️'],
            sports: ['⚽', '🏀', '🏈', '⚾', '🥎', '🏐', '🏉', '🎱', '🥏', '🏸', '🏒', '🏑', '🥍', '🏏', '🥅', '⛳', '🪁', '🏹', '🎣', '🥊']
        };
        const ALL_ICONS_COMBINED = [...new Set([...EMOJI_SETS.faces, ...EMOJI_SETS.fruits, ...EMOJI_SETS.animals, ...EMOJI_SETS.objects, ...EMOJI_SETS.sweets, ...EMOJI_SETS.vehicles, ...EMOJI_SETS.music, ...EMOJI_SETS.weather, ...EMOJI_SETS.sports])];


        // --- Level Definitions ---
        const levels = [
            { levelNumber: 1, levelName: "新手上路", timeLimit: 120, boardRows: 6, boardCols: 8, tileTypesCount: 8, maxErrors: 10, starsEarned: 0,
              theme: { name: "入门", backgroundColor: 'linear-gradient(135deg, #FFB6C1 0%, #89CFF0 100%)', iconSet: EMOJI_SETS.faces, bgmTheme: "入门" } },
            { levelNumber: 2, levelName: "水果乐园", timeLimit: 150, boardRows: 8, boardCols: 10, tileTypesCount: 10, maxErrors: 8, starsEarned: 0,
              theme: { name: "水果", backgroundColor: 'linear-gradient(135deg, #A8E063 0%, #56AB2F 100%)', iconSet: EMOJI_SETS.fruits, bgmTheme: "水果" } },
            { levelNumber: 3, levelName: "动物总动员", timeLimit: 180, boardRows: 8, boardCols: 12, tileTypesCount: 12, maxErrors: 7, starsEarned: 0,
              theme: { name: "动物", backgroundColor: 'linear-gradient(135deg, #F3A183 0%, #EC6F66 100%)', iconSet: EMOJI_SETS.animals, bgmTheme: "动物" } },
            { levelNumber: 4, levelName: "物品大挑战", timeLimit: 200, boardRows: 10, boardCols: 12, tileTypesCount: 15, maxErrors: 6, starsEarned: 0,
              theme: { name: "物品", backgroundColor: 'linear-gradient(135deg, #74EBD5 0%, #9FACE6 100%)', iconSet: EMOJI_SETS.objects, bgmTheme: "物品" } },
            { levelNumber: 5, levelName: "甜点时光", timeLimit: 210, boardRows: 10, boardCols: 14, tileTypesCount: 16, maxErrors: 5, starsEarned: 0,
              theme: { name: "甜点", backgroundColor: 'linear-gradient(135deg, #FFC0CB 0%, #FFDAB9 100%)', iconSet: EMOJI_SETS.sweets, bgmTheme: "甜点" } },
            { levelNumber: 6, levelName: "交通枢纽", timeLimit: 220, boardRows: 10, boardCols: 14, tileTypesCount: 18, maxErrors: 5, starsEarned: 0,
              theme: { name: "交通", backgroundColor: 'linear-gradient(135deg, #A0A0A0 0%, #505050 100%)', iconSet: EMOJI_SETS.vehicles, bgmTheme: "交通" } },
            { levelNumber: 7, levelName: "音乐盛会", timeLimit: 230, boardRows: 12, boardCols: 14, tileTypesCount: 18, maxErrors: 4, starsEarned: 0,
              theme: { name: "音乐", backgroundColor: 'linear-gradient(135deg, #D2B4DE 0%, #A569BD 100%)', iconSet: EMOJI_SETS.music, bgmTheme: "音乐" } },
            { levelNumber: 8, levelName: "天气播报", timeLimit: 240, boardRows: 12, boardCols: 16, tileTypesCount: 20, maxErrors: 4, starsEarned: 0,
              theme: { name: "天气", backgroundColor: 'linear-gradient(135deg, #87CEEB 0%, #4682B4 100%)', iconSet: EMOJI_SETS.weather, bgmTheme: "天气" } },
            { levelNumber: 9, levelName: "运动健将", timeLimit: 250, boardRows: 12, boardCols: 16, tileTypesCount: 20, maxErrors: 3, starsEarned: 0,
              theme: { name: "运动", backgroundColor: 'linear-gradient(135deg, #FF8C00 0%, #FF4500 100%)', iconSet: EMOJI_SETS.sports, bgmTheme: "运动" } },
            { levelNumber: 10, levelName: "终极混搭", timeLimit: 280, boardRows: 12, boardCols: 18, tileTypesCount: 22, maxErrors: 3, starsEarned: 0,
              theme: { name: "大师", backgroundColor: 'linear-gradient(135deg, #6a11cb 0%, #2575fc 100%)', iconSet: ALL_ICONS_COMBINED, bgmTheme: "大师" } }
        ];
        let currentLevelIndex = 0;
        let maxUnlockedLevel = 1;

        // Game Parameters (会被 updateGameParametersAndStyles 动态修改)
        let gameParams = {
            tileWidth: 48, tileHeight: 48, gap: 5, boardPadding: 10, fontSize: 26,
            boardRowsLogical: levels[0].boardRows,
            boardColsLogical: levels[0].boardCols,
            boardRowsPhysical: levels[0].boardRows + 2,
            boardColsPhysical: levels[0].boardCols + 2,
            timeLimit: levels[0].timeLimit,
            tileTypesCount: levels[0].tileTypesCount,
            totalLogicalTiles: levels[0].boardRows * levels[0].boardCols,
            currentIconSet: levels[0].theme.iconSet,
            maxErrorsAllowed: levels[0].maxErrors
        };

        const INITIAL_HINTS = 3;

        // Game State
        let gameBoardArray = [];
        let score = 0;
        let timeLeft = gameParams.timeLimit;
        let timerInterval = null;
        let firstSelectedTile = null;
        let remainingTiles = 0;
        let gameActive = false;
        let pathClearTimeout = null;
        let autoShuffleAttempts = 0;
        const MAX_AUTO_SHUFFLE_ATTEMPTS = 1;
        let hintCount = INITIAL_HINTS;
        let hintHighlightTimeout = null;
        let audioInitialized = false;
        let connectionErrors = 0;
        let currentBGMLoop = null;


        // --- Local Storage ---
        const STORAGE_KEY_MAX_LEVEL = 'lianliankan_maxUnlockedLevel_v8'; 
        const STORAGE_KEY_LEVELS_DATA = 'lianliankan_levelsData_v8';

        function saveProgress() {
            try {
                localStorage.setItem(STORAGE_KEY_MAX_LEVEL, maxUnlockedLevel.toString());
                localStorage.setItem(STORAGE_KEY_LEVELS_DATA, JSON.stringify(levels.map(l => ({ levelNumber: l.levelNumber, starsEarned: l.starsEarned }))));
            } catch (e) {
                console.error("Failed to save progress to localStorage:", e);
            }
        }
        function loadProgress() {
             try {
                const savedMaxLevel = localStorage.getItem(STORAGE_KEY_MAX_LEVEL);
                if (savedMaxLevel !== null) {
                    maxUnlockedLevel = parseInt(savedMaxLevel, 10);
                } else {
                    maxUnlockedLevel = 1;
                }
                const savedLevelsDataString = localStorage.getItem(STORAGE_KEY_LEVELS_DATA);
                if (savedLevelsDataString) {
                    const parsedSavedLevels = JSON.parse(savedLevelsDataString);
                    if (Array.isArray(parsedSavedLevels)) {
                        levels.forEach((currentLevelInCode) => {
                            const savedLevelData = parsedSavedLevels.find(sl => sl.levelNumber === currentLevelInCode.levelNumber);
                            if (savedLevelData && typeof savedLevelData.starsEarned !== 'undefined') {
                                currentLevelInCode.starsEarned = savedLevelData.starsEarned;
                            } else {
                                currentLevelInCode.starsEarned = currentLevelInCode.starsEarned || 0;
                            }
                        });
                    }
                } else {
                    levels.forEach(level => level.starsEarned = level.starsEarned || 0);
                }
            } catch (e) {
                console.error("Failed to load progress from localStorage:", e);
                maxUnlockedLevel = 1;
                levels.forEach(level => level.starsEarned = 0);
            }
        }


        // --- Audio Setup (Tone.js) ---
        let sounds = {};
        function initializeAudio() { 
            if (audioInitialized) return;
            sounds.click = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination();
            sounds.match1 = new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.05, release: 0.2 }, volume: -12 }).toDestination();
            sounds.match2 = new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.05, release: 0.2 }, volume: -12 }).toDestination();
            sounds.error = new Tone.Synth({ oscillator: { type: "square" }, envelope: { attack: 0.01, decay: 0.15, sustain: 0, release: 0.1 } }).toDestination();
            sounds.win = new Tone.PolySynth({ polyphony: 4, voice: Tone.Synth, options: { envelope: { attack: 0.05, decay: 0.5, sustain: 0.1, release: 1 } } }).toDestination();
            sounds.gameOver = new Tone.Synth({ oscillator: { type: "sawtooth" }, envelope: { attack: 0.1, decay: 0.8, sustain: 0, release: 0.5 } }).toDestination();
            sounds.buttonClick = new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 2, envelope: { attack: 0.001, decay: 0.1, sustain: 0 } }).toDestination();
            sounds.bgmSynth = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.1, decay: 0.3, sustain: 0.1, release: 1 }, volume: -25 }).toDestination();
            const filter = new Tone.Filter(800, "lowpass").toDestination();
            sounds.bgmSynth.connect(filter);
            sounds.bgmLoops = {
                "入门": new Tone.Loop(time => { sounds.bgmSynth.triggerAttackRelease("C4", "2n", time); sounds.bgmSynth.triggerAttackRelease("G4", "2n", time + Tone.Time("2n").toSeconds()); }, "1m"),
                "水果": new Tone.Loop(time => { sounds.bgmSynth.triggerAttackRelease("D4", "4n", time); sounds.bgmSynth.triggerAttackRelease("A4", "4n", time + 0.5); sounds.bgmSynth.triggerAttackRelease("F#4", "4n", time + 1); }, "2m"),
                "动物": new Tone.Loop(time => { sounds.bgmSynth.triggerAttackRelease("E4", "2n", time); sounds.bgmSynth.triggerAttackRelease("B3", "2n", time + 1); }, "2m"),
                "物品": new Tone.Loop(time => { sounds.bgmSynth.triggerAttackRelease("F4", "1m", time); }, "1m"),
                "甜点": new Tone.Loop(time => { sounds.bgmSynth.triggerAttackRelease("G4", "4n", time); sounds.bgmSynth.triggerAttackRelease("C5", "4n", time + 0.5); sounds.bgmSynth.triggerAttackRelease("E5", "4n", time + 1); }, "2m"),
                "交通": new Tone.Loop(time => { sounds.bgmSynth.triggerAttackRelease("A3", "2n", time); sounds.bgmSynth.triggerAttackRelease("E4", "2n", time + 1); }, "2m"),
                "音乐": new Tone.Loop(time => { const notes = ["C4", "D4", "E4", "F4", "G4", "A4", "B4", "C5"]; const note = notes[Math.floor(Math.random() * notes.length)]; sounds.bgmSynth.triggerAttackRelease(note, "4n", time); }, "1n"),
                "天气": new Tone.Loop(time => { sounds.bgmSynth.triggerAttackRelease("C4", "1m", time, 0.8); }, "1m"),
                "运动": new Tone.Loop(time => { sounds.bgmSynth.triggerAttackRelease("D4", "8n", time); sounds.bgmSynth.triggerAttackRelease("G4", "8n", time + 0.25); sounds.bgmSynth.triggerAttackRelease("A4", "8n", time + 0.5); }, "1n"),
                "大师": new Tone.Loop(time => { sounds.bgmSynth.triggerAttackRelease("C4", "1n", time); sounds.bgmSynth.triggerAttackRelease("F4", "1n", time + 1); sounds.bgmSynth.triggerAttackRelease("Bb3", "1n", time + 2); sounds.bgmSynth.triggerAttackRelease("Eb4", "1n", time + 3); }, "4m")
            };
            audioInitialized = true;
        }
        async function ensureAudioStarted() { 
            if (typeof Tone === 'undefined' || Tone === null) { return false; }
            if (Tone.context.state !== 'running') { try { await Tone.start(); } catch (e) { return false; } }
            if (!audioInitialized) { initializeAudio(); }
            return true;
         }
        async function playSound(soundType) { 
            const audioIsReady = await ensureAudioStarted();
            if (!audioIsReady || !audioInitialized || typeof Tone === 'undefined' || (soundType === 'match' && (!sounds.match1 || !sounds.match2)) || (soundType !== 'match' && !sounds[soundType])) { return; }
            const now = Tone.now(); try { switch(soundType) { case 'click': sounds.click.triggerAttackRelease("C5", "8n", now); break; case 'match': sounds.match1.triggerAttackRelease("E5", "8n", now); sounds.match2.triggerAttackRelease("G5", "8n", now + 0.15); break; case 'error': sounds.error.triggerAttackRelease("A2", "8n", now); break; case 'win': sounds.win.triggerAttackRelease(["C4", "E4", "G4", "C5"], "0.5n", now); sounds.win.triggerAttackRelease(["E4", "G4", "B4", "E5"], "0.5n", now + 0.4); sounds.win.triggerAttackRelease(["G4", "B4", "D5", "G5"], "0.5n", now + 0.8); break; case 'gameOver': sounds.gameOver.triggerAttackRelease("F#3", "1n", now); break; case 'buttonClick': sounds.buttonClick.triggerAttackRelease("C3", "16n", now); break; } } catch (e) { console.error("Error playing sound:", e); }
        }
        function playBGM(themeName) { 
            if (!audioInitialized || typeof Tone === 'undefined') return; stopBGM(); if (sounds.bgmLoops[themeName]) { currentBGMLoop = sounds.bgmLoops[themeName]; currentBGMLoop.start(0).stop(gameParams.timeLimit + 2); Tone.Transport.start(); } else { if (sounds.bgmLoops["入门"]) { currentBGMLoop = sounds.bgmLoops["入门"]; currentBGMLoop.start(0).stop(gameParams.timeLimit + 2); Tone.Transport.start(); } }
        }
        function stopBGM() { 
            if (typeof Tone === 'undefined') return; if (currentBGMLoop) { currentBGMLoop.stop(0); } Tone.Transport.stop(); Tone.Transport.cancel(); currentBGMLoop = null;
        }

        // --- Responsive Parameter Update ---
        function updateGameParametersAndStyles() {
            const iw = window.innerWidth;
            const gameContainerElement = gameWrapper.querySelector('.game-container');
            let effectiveBoardContainerWidth;

            if (gameWrapper.style.display !== 'none' && gameContainerElement && gameContainerElement.offsetWidth > 0) {
                effectiveBoardContainerWidth = gameContainerElement.clientWidth;
            } else {
                const typicalGameContainerPadding = (iw < 640 ? 10 : (iw < 768 ? 20 : 25)); 
                effectiveBoardContainerWidth = iw * 0.95 - (2 * typicalGameContainerPadding);
            }

            const currentBoardColsLogical = gameParams.boardColsLogical;
            let currentGap, currentBoardPaddingForBoardItself;

            if (iw < 480) { 
                currentGap = 2;
                currentBoardPaddingForBoardItself = 2; 
            } else if (iw < 768) { 
                currentGap = 3;
                currentBoardPaddingForBoardItself = 4;
            } else { 
                currentGap = 4;
                currentBoardPaddingForBoardItself = 5;
            }
            gameParams.gap = currentGap;

            const boardBorderThickness = 2;
            const spaceForBoardContentAndItsPadding = effectiveBoardContainerWidth - (2 * boardBorderThickness);
            const spaceForTilesAndGaps = spaceForBoardContentAndItsPadding - (2 * currentBoardPaddingForBoardItself);
            let calculatedTileWidth = (spaceForTilesAndGaps - (currentBoardColsLogical - 1) * currentGap) / currentBoardColsLogical;

            gameParams.tileWidth = Math.max(18, Math.floor(calculatedTileWidth)); 
            gameParams.tileHeight = gameParams.tileWidth;
            gameParams.fontSize = Math.max(10, Math.floor(gameParams.tileWidth * 0.62)); 

            document.documentElement.style.setProperty('--tile-font-size', gameParams.fontSize + 'px');
            gameParams.boardPadding = currentBoardPaddingForBoardItself;
            gameParams.boardRowsPhysical = gameParams.boardRowsLogical + 2;
            gameParams.boardColsPhysical = gameParams.boardColsLogical + 2;
        }


        // --- Helper Functions ---
        const CUTE_SUCCESS_MESSAGES = ["太棒啦！🎉", "真厉害！✨", "好样的！🥳", "漂亮！🌟", "完美！💖"];
        function showMessage(message, type = 'success', duration = 2000) { 
            let displayMessage = message; if (type === 'success' && message === "成功消除!") { displayMessage = CUTE_SUCCESS_MESSAGES[Math.floor(Math.random() * CUTE_SUCCESS_MESSAGES.length)]; } messageBox.textContent = displayMessage; messageBox.className = 'message-box'; messageBox.classList.add(type); if (messageBox.style.display === 'none') { messageBox.style.display = 'block'; requestAnimationFrame(() => { messageBox.classList.add('show'); }); } else { messageBox.classList.add('show'); } const effectiveDuration = (type === 'win' || type === 'gameover' || message.includes("自动洗牌") || message.includes("提示")) ? Math.max(duration, 3000) : duration; if (messageBox.hideTimeout) clearTimeout(messageBox.hideTimeout); messageBox.hideTimeout = setTimeout(() => { messageBox.classList.remove('show'); setTimeout(() => { if (!messageBox.classList.contains('show')) { messageBox.style.display = 'none'; } }, 350); }, effectiveDuration);
        }
        function shuffleArray(array) { 
             for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; }
        }
        function formatTime(seconds) { 
            const minutes = Math.floor(seconds / 60); const rs = seconds % 60; return `${minutes < 10 ? '0' : ''}${minutes}:${rs < 10 ? '0' : ''}${rs}`;
        }
        function updateHintsDisplay() { hintsDisplay.textContent = `提示: ${hintCount}`; }
        function updateErrorsDisplay() { errorsDisplay.textContent = `错误: ${connectionErrors}/${gameParams.maxErrorsAllowed}`; }


        // --- Canvas and Path Drawing ---
        function setupCanvas() { 
            const boardElementWidth = gameParams.boardColsLogical * gameParams.tileWidth + (gameParams.boardColsLogical - 1) * gameParams.gap + 2 * gameParams.boardPadding; const boardElementHeight = gameParams.boardRowsLogical * gameParams.tileHeight + (gameParams.boardRowsLogical - 1) * gameParams.gap + 2 * gameParams.boardPadding; pathCanvas.width = boardElementWidth; pathCanvas.height = boardElementHeight; pathCanvas.style.top = gameBoardElement.offsetTop + 'px'; pathCanvas.style.left = gameBoardElement.offsetLeft + 'px'; clearPathCanvas();
        }
        function clearPathCanvas() { pathCtx.clearRect(0, 0, pathCanvas.width, pathCanvas.height); }
        function getTileCenter(r_array_idx, c_array_idx) { 
            let x, y; if (c_array_idx === 0) { x = gameParams.boardPadding / 2 - gameParams.gap / 2; } else if (c_array_idx === gameParams.boardColsPhysical - 1) { x = gameParams.boardPadding + gameParams.boardColsLogical * gameParams.tileWidth + (gameParams.boardColsLogical -1) * gameParams.gap + gameParams.gap/2 + gameParams.boardPadding/2; } else { x = gameParams.boardPadding + (c_array_idx - 1) * (gameParams.tileWidth + gameParams.gap) + gameParams.tileWidth / 2; } if (r_array_idx === 0) { y = gameParams.boardPadding / 2 - gameParams.gap / 2; } else if (r_array_idx === gameParams.boardRowsPhysical - 1) { y = gameParams.boardPadding + gameParams.boardRowsLogical * gameParams.tileHeight + (gameParams.boardRowsLogical -1) * gameParams.gap + gameParams.gap/2 + gameParams.boardPadding/2; } else { y = gameParams.boardPadding + (r_array_idx - 1) * (gameParams.tileHeight + gameParams.gap) + gameParams.tileHeight / 2; } return { x, y };
        }
        function drawConnectionPath(pathPoints, color = 'var(--cute-blue)', duration = 500) { 
            if (!pathPoints || pathPoints.length < 2) return; clearPathCanvas(); pathCtx.beginPath(); pathCtx.strokeStyle = color; pathCtx.lineWidth = Math.max(3, gameParams.tileWidth / 12); pathCtx.lineCap = 'round'; pathCtx.lineJoin = 'round'; const firstPointCoords = getTileCenter(pathPoints[0].r, pathPoints[0].c); pathCtx.moveTo(firstPointCoords.x, firstPointCoords.y); for (let i = 1; i < pathPoints.length; i++) { const pointCoords = getTileCenter(pathPoints[i].r, pathPoints[i].c); pathCtx.lineTo(pointCoords.x, pointCoords.y); } pathCtx.stroke(); if (pathClearTimeout) clearTimeout(pathClearTimeout); pathClearTimeout = setTimeout(clearPathCanvas, duration);
        }

        // --- Timer Functions ---
        function startTimer() { 
            clearInterval(timerInterval); timeLeft = gameParams.timeLimit; timerDisplay.textContent = `时间: ${formatTime(timeLeft)}`; gameActive = true; timerInterval = setInterval(() => { timeLeft--; timerDisplay.textContent = `时间: ${formatTime(timeLeft)}`; if (timeLeft < 0) { timeLeft = 0; timerDisplay.textContent = `时间: ${formatTime(timeLeft)}`; handleGameOver("time"); } }, 1000);
        }

        // --- Pathfinding ---
        function isPathClear(r1,c1,r2,c2){if(r1===r2){for(let i=Math.min(c1,c2)+1;i<Math.max(c1,c2);i++)if(gameBoardArray[r1][i]!==null)return false;return true}if(c1===c2){for(let i=Math.min(r1,r2)+1;i<Math.max(r1,r2);i++)if(gameBoardArray[i][c1]!==null)return false;return true}return false}
        function checkZeroTurn(t1,t2){if(t1.r!==t2.r&&t1.c!==t2.c)return null;if(isPathClear(t1.r,t1.c,t2.r,t2.c))return[{r:t1.r,c:t1.c},{r:t2.r,c:t2.c}];return null}
        function checkOneTurn(t1,t2){const p1c={r:t1.r,c:t2.c},p2c={r:t2.r,c:t1.c};if(gameBoardArray[p1c.r][p1c.c]===null&&isPathClear(t1.r,t1.c,p1c.r,p1c.c)&&isPathClear(p1c.r,p1c.c,t2.r,t2.c))return[{r:t1.r,c:t1.c},p1c,{r:t2.r,c:t2.c}];if(gameBoardArray[p2c.r][p2c.c]===null&&isPathClear(t1.r,t1.c,p2c.r,p2c.c)&&isPathClear(p2c.r,p2c.c,t2.r,t2.c))return[{r:t1.r,c:t1.c},p2c,{r:t2.r,c:t2.c}];return null}
        function checkTwoTurnsComprehensive(t1,t2){for(let ci=0;ci<gameParams.boardColsPhysical;ci++){const p={r:t1.r,c:ci};if((gameBoardArray[p.r][p.c]===null||(p.r===t2.r&&p.c===t2.c))&&isPathClear(t1.r,t1.c,p.r,p.c)){const op=checkOneTurn(p,t2);if(op){if(p.r===t1.r&&p.c===t1.c&&!(p.r===op[1].r&&p.c===op[1].c))continue;if(!(p.r===t2.r&&p.c===t2.c)&&gameBoardArray[p.r][p.c]!==null)continue;return[{r:t1.r,c:t1.c},...op]}}}for(let ri=0;ri<gameParams.boardRowsPhysical;ri++){const p={r:ri,c:t1.c};if((gameBoardArray[p.r][p.c]===null||(p.r===t2.r&&p.c===t2.c))&&isPathClear(t1.r,t1.c,p.r,p.c)){const op=checkOneTurn(p,t2);if(op){if(p.r===t1.r&&p.c===t1.c&&!(p.r===op[1].r&&p.c===op[1].c))continue;if(!(p.r===t2.r&&p.c===t2.c)&&gameBoardArray[p.r][p.c]!==null)continue;return[{r:t1.r,c:t1.c},...op]}}}return null}
        function canConnect(t1,t2){if(t1.r===t2.r&&t1.c===t2.c)return null;let p;p=checkZeroTurn(t1,t2);if(p)return p;p=checkOneTurn(t1,t2);if(p)return p;p=checkTwoTurnsComprehensive(t1,t2);if(p)return p;return null}

        // --- "No More Moves" & Hint Logic ---
        function findAllPossibleMoves(){ 
            const at=[];for(let r=0;r<gameParams.boardRowsPhysical;r++)for(let c=0;c<gameParams.boardColsPhysical;c++)if(gameBoardArray[r][c]!==null){const e=gameBoardElement.querySelector(`.tile[data-row="${r}"][data-col="${c}"]`);at.push({r,c,icon:gameBoardArray[r][c],element:e})}if(at.length<2)return null;for(let i=0;i<at.length;i++)for(let j=i+1;j<at.length;j++){const t1=at[i],t2=at[j];if(t1.icon===t2.icon){const p=canConnect(t1,t2);if(p)return{tile1:t1,tile2:t2,path:p}}}return null
        }
        async function checkAndHandleNoMoreMoves(){ 
            if(remainingTiles===0||!gameActive)return;if(firstSelectedTile&&firstSelectedTile.element){firstSelectedTile.element.classList.remove('selected');firstSelectedTile=null;clearPathCanvas()}const pm=findAllPossibleMoves();if(!pm){if(autoShuffleAttempts<MAX_AUTO_SHUFFLE_ATTEMPTS){autoShuffleAttempts++;showMessage("没有可消除的方块了，尝试自动洗牌...","info",3e3);await new Promise(r=>setTimeout(r,2e3));await shuffleBoard(!0)}else{showMessage("自动洗牌后仍无解。请手动洗牌或重新开始。","error",5e3);playSound('error')}}else autoShuffleAttempts=0
        }
        async function provideHint(){ 
            await ensureAudioStarted();playSound('buttonClick');if(!gameActive||remainingTiles===0){showMessage("游戏尚未开始或已结束。","info");return}if(hintCount<=0){showMessage("提示次数已用完!","error");playSound('error');return}if(firstSelectedTile&&firstSelectedTile.element){firstSelectedTile.element.classList.remove('selected');firstSelectedTile=null}clearPathCanvas();if(hintHighlightTimeout)clearTimeout(hintHighlightTimeout);const m=findAllPossibleMoves();if(m&&m.tile1.element&&m.tile2.element){hintCount--;updateHintsDisplay();showMessage("找到可消除的方块!","info",1500);m.tile1.element.classList.add('hint-highlight');m.tile2.element.classList.add('hint-highlight');drawConnectionPath(m.path,'#FFD700',1500);hintHighlightTimeout=setTimeout(()=>{m.tile1.element.classList.remove('hint-highlight');m.tile2.element.classList.remove('hint-highlight')},1500)}else{showMessage("当前没有可用的提示。","info");playSound('error')}
        }

        // --- Modal Logic ---
        function createEndGameModal(title, message, buttons) { 
            endGameModalOverlay.innerHTML = ''; const modalContent = document.createElement('div'); modalContent.className = 'modal-content'; const titleElement = document.createElement('h2'); titleElement.textContent = title; modalContent.appendChild(titleElement); const messageElement = document.createElement('p'); messageElement.innerHTML = message; modalContent.appendChild(messageElement); const buttonsDiv = document.createElement('div'); buttonsDiv.className = 'modal-buttons'; buttons.forEach(buttonConfig => { const button = document.createElement('button'); button.textContent = buttonConfig.text; button.className = 'btn'; if (buttonConfig.styleClass) { button.classList.add(...buttonConfig.styleClass.split(' ')); } button.onclick = async () => { const audioCanPlay = await ensureAudioStarted(); if(audioCanPlay) playSound('buttonClick'); hideEndGameModal(); buttonConfig.action(); }; buttonsDiv.appendChild(button); }); modalContent.appendChild(buttonsDiv); endGameModalOverlay.appendChild(modalContent); endGameModalOverlay.classList.add('show');
        }
        function hideEndGameModal() { 
            endGameModalOverlay.classList.remove('show'); setTimeout(() => { if (!endGameModalOverlay.classList.contains('show')) { endGameModalOverlay.innerHTML = ''; } }, 300);
        }


        // --- Win/Clear/Fail Logic ---
        function handleGameOver(reason) { 
            clearInterval(timerInterval); gameActive = false; let reasonText = ""; if (reason === "time") reasonText = "时间耗尽！"; else if (reason === "errors") reasonText = "错误次数过多！"; stopBGM(); playSound('gameOver'); gameBoardElement.style.pointerEvents = 'none'; createEndGameModal( "闯关失败！", `太遗憾了，因为${reasonText}<br>这次没有成功哦，再试一次吧！`, [ { text: "重玩本关", action: () => initGame(currentLevelIndex), styleClass: "bg-yellow-500" }, { text: "返回选关", action: showLevelSelectScreen, styleClass: "bg-gray-400" } ] );
        }
        function checkWinCondition(){ 
            if(remainingTiles === 0 && gameActive){ clearInterval(timerInterval); gameActive = false; const currentLevel = levels[currentLevelIndex]; let starsEarned = 0; const timePercentage = (timeLeft / gameParams.timeLimit) * 100; if (timePercentage > 66) starsEarned = 3; else if (timePercentage > 33) starsEarned = 2; else if (timeLeft >= 0) starsEarned = 1; levels[currentLevelIndex].starsEarned = Math.max(levels[currentLevelIndex].starsEarned || 0, starsEarned); saveProgress(); stopBGM(); playSound('win'); gameBoardElement.style.pointerEvents = 'none'; clearPathCanvas(); let modalTitle = `太棒了！`; let modalMessage = `${currentLevel.levelName} 完成！<br>你获得了 ${'★'.repeat(starsEarned)}${'☆'.repeat(3-starsEarned)}！`; let modalButtons = []; if (currentLevelIndex + 1 < levels.length) { maxUnlockedLevel = Math.max(maxUnlockedLevel, currentLevel.levelNumber + 1); saveProgress(); modalButtons.push({ text: "下一关卡", action: () => { currentLevelIndex++; actualGameStart(); }, styleClass: "bg-green-500" }); } else { modalMessage += "<br>所有关卡都已完成！🥳"; } modalButtons.push({ text: "重玩本关", action: () => initGame(currentLevelIndex) }); modalButtons.push({ text: "返回选关", action: showLevelSelectScreen, styleClass: "bg-gray-400" }); createEndGameModal(modalTitle, modalMessage, modalButtons); }
        }
        function clearTiles(t1,t2,cp){drawConnectionPath(cp);playSound('match');setTimeout(async()=>{t1.element.classList.add('cleared');t1.element.classList.remove('selected');t2.element.classList.add('cleared');t2.element.classList.remove('selected');gameBoardArray[t1.r][t1.c]=null;gameBoardArray[t2.r][t2.c]=null;score+=10;remainingTiles-=2;scoreDisplay.textContent=`得分: ${score}`; showMessage("成功消除!", "success", 1000); if(remainingTiles>0&&gameActive){await new Promise(r=>setTimeout(r,50));await checkAndHandleNoMoreMoves()}setTimeout(checkWinCondition,100)},100)}

        // --- Game Setup and UI ---
        function createTilesList() { 
            const numTileTypes = gameParams.tileTypesCount; const totalTilesForLevel = gameParams.totalLogicalTiles; const currentIconSet = gameParams.currentIconSet; if (totalTilesForLevel % 2 !== 0) { showMessage("当前关卡棋盘大小设置错误!", "error"); return []; } if (numTileTypes > currentIconSet.length) { console.warn(`Level requires ${numTileTypes} types, but icon set only has ${currentIconSet.length}. Using all available.`); } const tiles = []; const iconsToUse = currentIconSet.slice(0, Math.min(numTileTypes, currentIconSet.length)); const numPairs = totalTilesForLevel / 2; for (let i = 0; i < numPairs; i++) { const icon = iconsToUse[i % iconsToUse.length]; tiles.push(icon, icon); } shuffleArray(tiles); return tiles;
        }
        function renderBoard(){ 
            gameBoardElement.innerHTML=''; gameBoardElement.style.gridTemplateColumns=`repeat(${gameParams.boardColsLogical}, ${gameParams.tileWidth}px)`; gameBoardElement.style.gridTemplateRows=`repeat(${gameParams.boardRowsLogical}, ${gameParams.tileHeight}px)`; gameBoardElement.style.gap=`${gameParams.gap}px`; gameBoardElement.style.padding=`${gameParams.boardPadding}px`; gameBoardElement.style.pointerEvents='auto'; setTimeout(() => { setupCanvas(); }, 0); for(let r_arr = 1; r_arr <= gameParams.boardRowsLogical; r_arr++) { for(let c_arr = 1; c_arr <= gameParams.boardColsLogical; c_arr++) { const tileDiv=document.createElement('div'); tileDiv.dataset.row = r_arr; tileDiv.dataset.col = c_arr; const icon=gameBoardArray[r_arr][c_arr]; if(icon){tileDiv.classList.add('tile');tileDiv.textContent=icon;tileDiv.addEventListener('click',handleTileClick)} else {tileDiv.classList.add('tile','empty');} gameBoardElement.appendChild(tileDiv); } }
        }
        async function handleTileClick(e){ 
            const clickedElement=e.currentTarget;if(!clickedElement||!clickedElement.dataset)return; const audioCanPlay = await ensureAudioStarted(); if(!gameActive)return; const rowStr=clickedElement.dataset.row, colStr=clickedElement.dataset.col;if(typeof rowStr==='undefined'||typeof colStr==='undefined')return; const r=parseInt(rowStr),c=parseInt(colStr);if(isNaN(r)||isNaN(c))return; if(!gameBoardArray[r] || typeof gameBoardArray[r][c] === 'undefined'){ console.error("Clicked tile's array data is invalid", {r,c}); return; } const icon=gameBoardArray[r][c];if(!icon||clickedElement.classList.contains('cleared'))return; if(audioCanPlay)playSound('click'); const hintHighlightedTiles=gameBoardElement.querySelectorAll('.hint-highlight'); hintHighlightedTiles.forEach(ht=>ht.classList.remove('hint-highlight')); if(hintHighlightTimeout)clearTimeout(hintHighlightTimeout); if(!firstSelectedTile){firstSelectedTile={element:clickedElement,r,c,icon:icon};clickedElement.classList.add('selected')} else{ if(firstSelectedTile.element===clickedElement){clickedElement.classList.remove('selected');firstSelectedTile=null} else{ const secondSelectedTile={element:clickedElement,r,c,icon:icon}; if(firstSelectedTile.icon===secondSelectedTile.icon){ const connectionPath=canConnect(firstSelectedTile,secondSelectedTile); if(connectionPath){clearTiles(firstSelectedTile,secondSelectedTile,connectionPath);firstSelectedTile=null} else{ showMessage("这两个图案无法连接!","error",1500);if(audioCanPlay)playSound('error'); connectionErrors++; updateErrorsDisplay(); if (connectionErrors >= gameParams.maxErrorsAllowed) { handleGameOver("errors"); return; } firstSelectedTile.element.classList.remove('selected');firstSelectedTile=null; } }else{ showMessage("图案不匹配!","error",1e3);if(audioCanPlay)playSound('error'); connectionErrors++; updateErrorsDisplay(); if (connectionErrors >= gameParams.maxErrorsAllowed) { handleGameOver("errors"); return; } firstSelectedTile.element.classList.remove('selected'); secondSelectedTile.element.classList.add('selected');firstSelectedTile=secondSelectedTile; } } }
        }
        async function shuffleBoard(isAutoShuffle=false){ 
            let audioCanPlay = false; if(!isAutoShuffle){audioCanPlay = await ensureAudioStarted();if(audioCanPlay)playSound('buttonClick')} if(!gameActive&&remainingTiles>0){}else if(!gameActive&&remainingTiles===0){showMessage("游戏已通关，无需洗牌。","info");return}else if(!gameActive){showMessage("游戏尚未开始，无需洗牌。","info");return}if(remainingTiles===0){showMessage("所有方块都已消除，无需洗牌。","info");return} const currentTilesData=[];for(let r=1;r<=gameParams.boardRowsLogical;r++)for(let c=1;c<=gameParams.boardColsLogical;c++)if(gameBoardArray[r][c]!==null)currentTilesData.push({icon:gameBoardArray[r][c],r_orig:r,c_orig:c});if(currentTilesData.length===0){if(!isAutoShuffle)showMessage("没有可洗牌的方块了。","info");return} const iconsOnly=currentTilesData.map(t=>t.icon);shuffleArray(iconsOnly);for(let i=0;i<currentTilesData.length;i++){const originalPos=currentTilesData[i];gameBoardArray[originalPos.r_orig][originalPos.c_orig]=iconsOnly[i]} if(firstSelectedTile&&firstSelectedTile.element)firstSelectedTile.element.classList.remove('selected');firstSelectedTile=null;clearPathCanvas();renderBoard();if(!isAutoShuffle){showMessage("棋盘已洗牌!","info",1500);autoShuffleAttempts=0}await new Promise(r=>setTimeout(r,50));await checkAndHandleNoMoreMoves()
        }

        let resizeTimeout;
        function handleWindowResize(){ 
            clearTimeout(resizeTimeout);resizeTimeout=setTimeout(async()=>{ updateGameParametersAndStyles(); if(gameActive && gameWrapper.style.display !== 'none') { await initGame(currentLevelIndex); } else if (mainMenuContainer.style.display !== 'none' && !gameActive) { if (mainMenuContainer.querySelector('#levelListContainer')) { showLevelSelectScreen(); } else { showMainMenuScreen(); } } },250)
        }

        function showMainMenuScreen() {
            if (!mainMenuContainer) {
                // console.error("mainMenuContainer is null in showMainMenuScreen. Cannot display main menu.");
                return;
            }
            mainMenuContainer.innerHTML = ''; // Explicitly clear previous content
            mainMenuContainer.innerHTML = `<h1 class="main-title">可爱连连看乐园</h1><button id="initialStartGameButton">开始挑战！</button>`;
            mainMenuContainer.style.display = 'flex';
            gameWrapper.style.display = 'none';
            
            try {
                stopBGM();
            } catch (e) {
                // console.error("Error stopping BGM in showMainMenuScreen:", e);
            }

            const initialStartBtn = document.getElementById('initialStartGameButton');
            if (initialStartBtn) {
                initialStartBtn.onclick = async () => {
                    const audioCanPlay = await ensureAudioStarted();
                    if(audioCanPlay) playSound('buttonClick');
                    showLevelSelectScreen();
                };
            } else {
                // console.error("initialStartGameButton NOT found after setting innerHTML in showMainMenuScreen.");
            }
        }

        function showLevelSelectScreen() {
            if (!mainMenuContainer) {
                // console.error("mainMenuContainer is null in showLevelSelectScreen.");
                return;
            }
            mainMenuContainer.innerHTML = ''; // Explicitly clear
            mainMenuContainer.innerHTML = '<h1 class="level-select-title">选择关卡</h1>';
            const levelListDiv = document.createElement('div');
            levelListDiv.id = 'levelListContainer';
            levels.forEach((level, index) => {
                const levelButton = document.createElement('button');
                const stars = level.starsEarned || 0;
                const starIcons = `<span class="stars-display"><span class="star-filled">${'★'.repeat(stars)}</span><span class="star-empty">${'☆'.repeat(3-stars)}</span></span>`;
                levelButton.innerHTML = `第 ${level.levelNumber} 关 <br> <span class="level-name">${level.levelName}</span> ${starIcons}`;
                levelButton.className = 'level-button';
                if (level.levelNumber > maxUnlockedLevel) {
                    levelButton.disabled = true;
                    levelButton.innerHTML = `第 ${level.levelNumber} 关 <br> <span class="level-name">${level.levelName}</span> <span class="lock-icon">🔒</span>`;
                } else {
                    levelButton.onclick = async () => {
                        const audioCanPlay = await ensureAudioStarted();
                        if(audioCanPlay) playSound('buttonClick');
                        currentLevelIndex = index;
                        actualGameStart();
                    };
                }
                levelListDiv.appendChild(levelButton);
            });
            mainMenuContainer.appendChild(levelListDiv);
            mainMenuContainer.style.display = 'flex';
            gameWrapper.style.display = 'none';
            try {
                stopBGM();
            } catch (e) {
                // console.error("Error stopping BGM in showLevelSelectScreen:", e);
            }
        }

        async function actualGameStart() { 
            mainMenuContainer.style.display = 'none'; gameWrapper.style.display = 'flex'; await initGame(currentLevelIndex);
        }

        async function initGame(levelIdx) { 
            currentLevelIndex = levelIdx; const currentLevel = levels[currentLevelIndex]; gameParams.boardRowsLogical = currentLevel.boardRows; gameParams.boardColsLogical = currentLevel.boardCols; gameParams.timeLimit = currentLevel.timeLimit; gameParams.tileTypesCount = currentLevel.tileTypesCount; gameParams.totalLogicalTiles = currentLevel.boardRows * currentLevel.boardCols; gameParams.currentIconSet = currentLevel.theme.iconSet; gameParams.maxErrorsAllowed = currentLevel.maxErrors; gameParams.boardRowsPhysical = currentLevel.boardRows + 2; gameParams.boardColsPhysical = currentLevel.boardCols + 2; document.body.style.background = currentLevel.theme.backgroundColor; levelTitleElement.textContent = `第 ${currentLevel.levelNumber} 关: ${currentLevel.levelName}`; levelSelectButton.style.backgroundColor = "var(--cute-purple)"; levelSelectButton.style.color = "var(--text-dark)"; levelSelectButton.style.display = 'flex'; levelSelectButton.onclick = async () => { const audioCanPlay = await ensureAudioStarted(); if(audioCanPlay) playSound('buttonClick'); gameActive = false; clearInterval(timerInterval); stopBGM(); showLevelSelectScreen(); }; if (controls) { const existingNextLevelButton = controls.querySelector('.next-level-btn'); if (existingNextLevelButton) { existingNextLevelButton.remove(); } } updateGameParametersAndStyles(); clearInterval(timerInterval); if(pathClearTimeout) clearTimeout(pathClearTimeout); if(hintHighlightTimeout) clearTimeout(hintHighlightTimeout); firstSelectedTile = null; gameBoardArray = Array(gameParams。boardRowsPhysical).fill(null).map(() => Array(gameParams.boardColsPhysical).fill(null)); remainingTiles = gameParams.totalLogicalTiles; autoShuffleAttempts = 0; hintCount = INITIAL_HINTS; connectionErrors = 0; updateHintsDisplay(); updateErrorsDisplay(); const tilesList = createTilesList(); if (tilesList.length === 0 && gameParams.totalLogicalTiles > 0) { return; } let tileIdx = 0; for (let r = 1; r <= gameParams.boardRowsLogical; r++) { for (let c = 1; c <= gameParams.boardColsLogical; c++) { if (tileIdx < tilesList.length) gameBoardArray[r][c] = tilesList[tileIdx++]; } } renderBoard(); score = 0; scoreDisplay.textContent = `得分: ${score}`; await ensureAudioStarted(); playBGM(currentLevel.theme.name); startTimer(); await new Promise(resolve => setTimeout(resolve, 100)); await checkAndHandleNoMoreMoves(); gameActive = true;
        }

        restartButton.addEventListener('click', async () => { 
            const audioCanPlay = await ensureAudioStarted(); if(audioCanPlay) playSound('buttonClick'); stopBGM(); initGame(currentLevelIndex);
        });
        shuffleButton.addEventListener('click', () => shuffleBoard(false));
        hintButton.addEventListener('click', provideHint);

        document.body.addEventListener('click', ensureAudioStarted, { once: true });
        window.addEventListener('resize', handleWindowResize);

        window.onload = () => { 
            if (!mainMenuContainer) {
                // console.error("FATAL: mainMenuContainer not found on window.onload.");
                return;
            }
            loadProgress(); 
            updateGameParametersAndStyles(); 
            mainMenuContainer.style.display = 'flex'; 
            gameWrapper.style.display = 'none'; 
            showMainMenuScreen(); 
        };
    </script>
</body>
</html>
�
