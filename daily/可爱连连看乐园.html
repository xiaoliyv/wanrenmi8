<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¯çˆ±è¿è¿çœ‹ä¹å›­</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --tile-font-size: 26px; /* ä¼šè¢«JSåŠ¨æ€ä¿®æ”¹ */
            --cute-blue: #89CFF0;
            --cute-pink: #FFB6C1;
            --cute-green: #90EE90;
            --cute-yellow: #FFFACD;
            --cute-purple: #E6E6FA;
            --text-dark: #4A5568;
            --text-medium: #718096;
            --locked-color: #CBD5E0;
            --star-filled-color: #FFD700;
            --star-empty-color: #E2E8F0;
            --button-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --button-hover-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        body {
            font-family: 'Nunito', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            transition: background 0.5s ease-in-out;
            overflow-x: hidden; /* é˜²æ­¢æ°´å¹³æ»šåŠ¨ */
            background: linear-gradient(135deg, var(--cute-pink) 0%, var(--cute-blue) 100%);
        }
        #mainMenuContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 15px;
            width: 100%;
            min-height: 80vh;
        }
        .main-title {
            font-size: 2.8rem;
            color: white;
            text-shadow: 2px 2px 5px rgba(0,0,0,0.25);
            margin-bottom: 30px;
            font-weight: 900;
            letter-spacing: -0.02em;
            line-height: 1.1;
        }
        #initialStartGameButton {
            padding: 15px 35px;
            font-size: 1.5rem;
            font-weight: 800;
            color: var(--text-dark);
            background-color: var(--cute-green);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.25s cubic-bezier(0.175, 0.885, 0.32, 1.275), box-shadow 0.25s ease;
            box-shadow: var(--button-shadow);
        }
        #initialStartGameButton:hover {
            transform: scale(1.08) rotate(-2deg);
            box-shadow: var(--button-hover-shadow);
            background-color: #A9F5A9;
        }

        .level-select-title {
            font-size: 2rem;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            margin-bottom: 20px;
            font-weight: 800;
        }
        #levelListContainer {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 10px;
            width: 100%;
            max-width: 95vw;
        }
        .level-button {
            padding: 10px 12px;
            font-size: 0.9rem;
            font-weight: 700;
            color: var(--text-dark);
            background-color: var(--cute-yellow);
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 15px;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease;
            box-shadow: var(--button-shadow);
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .level-button:hover:not(:disabled) {
            transform: translateY(-2px) scale(1.02);
            box-shadow: var(--button-hover-shadow);
            background-color: #fff7d6;
        }
        .level-button:disabled {
            background-color: var(--locked-color);
            color: #e2e8f0;
            cursor: not-allowed;
            opacity: 0.7;
            border-color: rgba(0,0,0,0.1);
        }
         .level-button .level-name {
            font-size:0.75em;
            color: var(--text-medium);
            margin-top: 3px;
        }
        .level-button .stars-display {
            font-size: 1em;
            margin-top: 5px;
            line-height: 1;
        }
        .level-button .stars-display .star-filled { color: var(--star-filled-color); }
        .level-button .stars-display .star-empty { color: var(--star-empty-color); }
         .level-button .lock-icon {
            margin-left: 6px;
            font-size: 0.8em;
        }

        .game-wrapper {
            display: none;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }
        .game-container { /* æ¸¸æˆåŒºåŸŸä¸»å®¹å™¨ */
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px; /* ç§»åŠ¨ç«¯å†…è¾¹è·å‡å° */
            background-color: rgba(255, 255, 255, 0.92);
            backdrop-filter: blur(8px);
            border-radius: 20px;
            box-shadow: 0 6px 15px rgba(0,0,0,0.1);
            width: 95vw; /* å®¹å™¨å®½åº¦ */
            max-width: 98vw;
            border: 1px solid rgba(255,255,255,0.25);
            margin: 10px 0;
            box-sizing: border-box; /* ç¡®ä¿paddingå’Œborderä¸å¢åŠ æ€»å®½åº¦ */
        }
        .game-title {
            font-size: 1.4rem; /* ç§»åŠ¨ç«¯æ ‡é¢˜ç¨å° */
            font-weight: 800;
            margin-bottom: 8px; /* å‡å°é—´è· */
            color: var(--text-dark);
            text-align: center;
        }
        /* --- OPTIMIZATION 1: Info Panel --- */
        .info-panel {
            display: flex;
            flex-direction: row; /* æ”¹ä¸ºè¡Œæ’åˆ— */
            flex-wrap: wrap; /* å…è®¸æ¢è¡Œ */
            justify-content: center; /* å±…ä¸­æ˜¾ç¤º */
            align-items: center;
            gap: 5px; /* é¡¹ç›®ä¹‹é—´çš„é—´éš™ */
            width: 100%;
            margin-bottom: 8px; /* å‡å°é—´è· */
            font-weight: 600;
        }
        .info-panel span {
            padding: 4px 6px; /* å‡å°å†…è¾¹è· */
            background-color: var(--cute-yellow);
            border-radius: 6px; /* å‡å°åœ†è§’ */
            text-align: center;
            color: var(--text-dark);
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            margin: 2px;
            font-size: 0.75rem; /* ç§»åŠ¨ç«¯æ˜¾è‘—ç¼©å°å­—ä½“ */
            min-width: auto; /* ç§»é™¤æœ€å°å®½åº¦ï¼Œè®©å…¶è‡ªé€‚åº”å†…å®¹ */
            flex-shrink: 0; /* é˜²æ­¢è¢«è¿‡åº¦å‹ç¼© */
        }
         #errorsDisplay {
            color: #ef4444;
        }

        .board-area { /* æ£‹ç›˜å’Œè·¯å¾„ç”»å¸ƒçš„ç›´æ¥å®¹å™¨ */
            position: relative;
            width: 100%; /* å æ»¡ game-container çš„å¯ç”¨å®½åº¦ */
            display: flex;
            justify-content: center;
            margin-bottom: 8px; /* å‡å°é—´è· */
        }

        .game-board { /* å®é™…çš„æ£‹ç›˜ç½‘æ ¼ */
            display: grid;
            border: 2px solid var(--cute-purple); /* æ£‹ç›˜è¾¹æ¡† */
            border-radius: 10px; /* å‡å°åœ†è§’ */
            background-color: rgba(255, 255, 255, 0.7);
            position: relative;
            z-index: 1;
            box-sizing: border-box; /* è¾¹æ¡†å’Œå†…è¾¹è·åŒ…å«åœ¨å®½é«˜å†… */
        }
        #pathCanvas {
            position: absolute;
            pointer-events: none;
            z-index: 2;
        }

        .tile {
            background-color: var(--cute-purple);
            border: 1px solid rgba(0,0,0,0.05);
            border-radius: 6px; /* å‡å°åœ†è§’ */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: var(--tile-font-size); /* JSä¼šè®¾ç½®è¿™ä¸ªå˜é‡ */
            cursor: pointer;
            transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1),
                        background-color 0.15s ease,
                        box-shadow 0.2s ease;
            box-shadow: 0 2px 3px rgba(0,0,0,0.08);
            width: 100%; /* ç¡®ä¿å¡«æ»¡gridå•å…ƒæ ¼ */
            height: 100%;
            box-sizing: border-box;
            overflow: hidden; /* é˜²æ­¢è¡¨æƒ…ç¬¦å·æº¢å‡ºå°å›¾å— */
            text-align: center; /* è¡¨æƒ…ç¬¦å·å±…ä¸­ */
            line-height: 1; /* ç¡®ä¿è¡¨æƒ…ç¬¦å·å‚ç›´å±…ä¸­ */
        }
        .tile:not(.selected):not(.empty):not(.cleared):hover {
            background-color: var(--cute-pink);
            transform: translateY(-1px) scale(1.02);
            box-shadow: 0 3px 6px rgba(0,0,0,0.1);
        }
        .tile.selected {
            background-color: var(--cute-green);
            border-color: #76D7C4;
            color: var(--text-dark);
            transform: scale(1.08);
            box-shadow: 0 0 10px var(--cute-green), 0 0 4px var(--cute-green);
        }
        .tile.hint-highlight {
            background-color: #FFD700 !important;
            border-color: #FFC400 !important;
            box-shadow: 0 0 12px #FFD700, 0 0 6px #FFC400 !important;
            transform: scale(1.1) !important;
        }
        .tile.empty {
            background-color: transparent !important;
            border: none !important;
            box-shadow: none !important;
            cursor: default;
        }
        .tile.cleared {
            transform: scale(0.3) rotate(20deg) translateY(-20px);
            opacity: 0;
            cursor: default;
            pointer-events: none;
            transition: transform 0.4s cubic-bezier(0.68, -0.55, 0.27, 1.55), opacity 0.3s ease;
        }
        .controls {
            margin-top: 10px; /* å‡å°é—´è· */
            display: flex;
            flex-wrap: nowrap;
            justify-content: space-around; /* æ”¹ä¸ºspace-aroundè®©æŒ‰é’®åˆ†å¸ƒæ›´å‡åŒ€ */
            gap: 8px; /* å¢å¤§æŒ‰é’®é—´éš™ */
            width: 100%;
            max-width: 320px; /* ç§»åŠ¨ç«¯æ§åˆ¶æŒ‰é’®åŒºåŸŸæœ€å¤§å®½åº¦ */
        }
        .btn.icon-btn {
            padding: 8px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 1.1rem;
        }
        .btn.icon-btn svg {
            margin-right: 0;
            width: 1.3em;
            height: 1.3em;
        }

        .btn {
            padding: 8px 15px;
            font-size: 0.85rem;
            font-weight: 700;
            color: white;
            background-color: var(--cute-blue);
            border: none;
            border-radius: 20px;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease, background-color 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--button-shadow);
            text-shadow: 1px 1px 1px rgba(0,0,0,0.1);
        }
        .btn svg {
            width: 1em;
            height: 1em;
            margin-right: 0.4em;
        }
        .btn:hover {
            transform: translateY(-1px) scale(1.02);
            box-shadow: var(--button-hover-shadow);
        }
        .btn:active {
            transform: translateY(0px) scale(0.98);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .btn.bg-green-500 { background-color: var(--cute-green); color: var(--text-dark); }
        .btn.bg-green-500:hover { background-color: #A9F5A9; }
        .btn.bg-yellow-500 { background-color: #FFD700; color: var(--text-dark); }
        .btn.bg-yellow-500:hover { background-color: #FFDB58; }

        #message-box {
            position: fixed;
            top: 15px;
            left: 50%;
            transform: translateX(-50%) translateY(-60px);
            color: var(--text-dark);
            padding: 10px 18px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.15);
            z-index: 1000;
            opacity: 0;
            font-size: 0.95rem;
            font-weight: 600;
            transition: opacity 0.3s ease, transform 0.35s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            display: none;
            text-align: center;
        }
        #message-box.success { background-color: var(--cute-green); }
        #message-box.error { background-color: #FFC0CB; }
        #message-box.win { background-color: #FFD700; }
        #message-box.info { background-color: var(--cute-blue); color: white; }
        #message-box.gameover { background-color: #B0C4DE; }
        #message-box.show {
            display: block;
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        .modal-overlay.show {
            display: flex;
            opacity: 1;
        }
        .modal-content {
            background-color: white;
            padding: 25px 30px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            text-align: center;
            max-width: 85vw;
            width: 350px;
            transform: scale(0.9);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .modal-overlay.show .modal-content {
            transform: scale(1);
        }
        .modal-content h2 {
            font-size: 1.8rem;
            font-weight: 800;
            color: var(--text-dark);
            margin-bottom: 12px;
        }
        .modal-content p {
            font-size: 1rem;
            color: var(--text-medium);
            margin-bottom: 20px;
            line-height: 1.5;
        }
        .modal-buttons {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        .modal-buttons .btn {
            min-width: 140px;
            width: 100%;
            max-width: 200px;
            font-size: 0.9rem;
            padding: 10px 15px;
        }


        @media (min-width: 640px) { /* å¹³æ¿ç­‰ç¨å¤§å±å¹• */
            .game-container { padding: 20px; }
            .game-title { font-size: 1.8rem; margin-bottom: 15px;} /* æ¡Œé¢ç«¯æ ‡é¢˜ä¹Ÿå¯ä»¥ç¨å¤§ */
            .info-panel {
                gap: 10px; /* æ¡Œé¢ç«¯é—´éš™å¯ä»¥å¤§ä¸€äº› */
                margin-bottom: 15px;
            }
            .info-panel span {
                padding: 5px 10px;
                font-size: 0.9rem; /* æ¡Œé¢ç«¯å­—ä½“å¯ä»¥ç¨å¤§ */
            }
            .board-area { margin-bottom: 15px; }
            .controls { margin-top: 20px; gap: 15px; max-width: 400px; }
            .btn.icon-btn { width: 45px; height: 45px; } /* æ¡Œé¢ç«¯å›¾æ ‡æŒ‰é’®ç¨å¤§ */
            .btn.icon-btn svg { width: 1.4em; height: 1.4em;}

            .main-title { font-size: 4rem; margin-bottom: 50px;}
            #initialStartGameButton { font-size: 2rem; padding: 22px 50px;}
            .level-select-title { font-size: 2.8rem; }
            .level-button { font-size: 1.2rem; padding: 18px 25px; }
            #message-box { font-size: 1.2rem; padding: 20px 30px; }
            .modal-content { width: 450px; padding: 35px 50px;}
            .modal-content h2 { font-size: 2.2rem; }
            .modal-content p { font-size: 1.2rem; }
            .modal-buttons {
                flex-direction: row;
                justify-content: center;
                gap: 15px;
                flex-wrap: wrap;
            }
            .modal-buttons .btn { width: auto; }
        }
         @media (min-width: 768px) { /* æ›´å¤§å±å¹• */
             .game-container { padding: 25px; max-width: 700px; }
             #levelListContainer { max-width: 700px; }
             .btn.icon-btn { width: 50px; height: 50px; }
             .btn.icon-btn svg { width: 1.5em; height: 1.5em;}
        }
    </style>
</head>
<body>
    <div id="mainMenuContainer">
        </div>

    <div class="game-wrapper"> <div class="game-container"> <h1 class="game-title" id="levelTitle">åŠ æ²¹ï¼è¿èµ·æ¥ï¼</h1>
            <div class="info-panel">
                <span id="timer">æ—¶é—´: 00:00</span>
                <span id="score">å¾—åˆ†: 0</span>
                <span id="hints">æç¤º: 3</span>
                <span id="errorsDisplay">é”™è¯¯: 0/0</span>
            </div>

            <div class="board-area"> <div id="gameBoard" class="game-board">
                    </div>
                <canvas id="pathCanvas"></canvas>
            </div>

            <div class="controls">
                <button id="restartButton" class="btn icon-btn" title="é‡ç©æœ¬å…³">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0 3.181 3.183a8.25 8.25 0 0 0 13.803-3.7M4.031 9.865a8.25 8.25 0 0 1 13.803-3.7l3.181 3.182m0-4.991v4.99" />
                    </svg>
                </button>
                <button id="shuffleButton" class="btn icon-btn bg-green-500" title="æ´—ç‰Œç‰Œ">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M7.5 21 3 16.5m0 0L7.5 12M3 16.5h13.5m0-13.5L21 7.5m0 0L16.5 12M21 7.5H7.5" />
                    </svg>
                </button>
                <button id="hintButton" class="btn icon-btn bg-yellow-500" title="å°æç¤º">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M12 18v-5.25m0 0a6.01 6.01 0 0 0 1.5-.189m-1.5.189a6.01 6.01 0 0 1-1.5-.189m3.75 7.478a12.06 12.06 0 0 1-4.5 0m3.75 2.354a15.054 15.054 0 0 1-4.5 0M3.75 10.5h.008v.008H3.75V10.5Zm0 3.75h.008v.008H3.75V14.25Zm0 3.75h.008v.008H3.75V18Zm16.5-3.75h.008v.008H20.25V14.25Zm0 3.75h.008v.008H20.25V18Zm0 3.75h.008v.008H20.25V21.75Zm-3.75-11.25h.008v.008H16.5V10.5Zm0 3.75h.008v.008H16.5V14.25Zm0 3.75h.008v.008H16.5V18Z" />
                    </svg>
                </button>
                 <button id="levelSelectButton" class="btn icon-btn" style="background-color: var(--cute-purple); color: var(--text-dark);" title="å…³å¡é€‰æ‹©">
                     <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"> <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 5.25h16.5m-16.5 4.5h16.5m-16.5 4.5h16.5m-16.5 4.5h16.5" /> </svg>
                </button>
            </div>
        </div>
    </div>

    <div id="message-box"></div>
    <div id="endGameModalOverlay" class="modal-overlay"></div>

    <script>
        // DOM Elements
        const mainMenuContainer = document.getElementById('mainMenuContainer');
        const gameWrapper = document.querySelector('.game-wrapper');
        const levelTitleElement = document.getElementById('levelTitle');
        const gameBoardElement = document.getElementById('gameBoard');
        const pathCanvas = document.getElementById('pathCanvas');
        const pathCtx = pathCanvas.getContext('2d');
        const restartButton = document.getElementById('restartButton');
        const shuffleButton = document.getElementById('shuffleButton');
        const hintButton = document.getElementById('hintButton');
        const levelSelectButton = document.getElementById('levelSelectButton');
        const timerDisplay = document.getElementById('timer');
        const scoreDisplay = document.getElementById('score');
        const hintsDisplay = document.getElementById('hints');
        const errorsDisplay = document.getElementById('errorsDisplay');
        const messageBox = document.getElementById('message-box');
        const controls = document.querySelector('.controls');

        // --- Emoji Icon Sets for Themes ---
        const EMOJI_SETS = {
            faces: ['ğŸ˜€', 'ğŸ˜‚', 'ğŸ˜Š', 'ğŸ˜', 'ğŸ¤”', 'ğŸ˜', 'ğŸ‘»', 'ğŸ‘½', 'ğŸ‘¾', 'ğŸ¤–', 'ğŸƒ', 'ğŸ¤¡', 'ğŸ¥³', 'ğŸ¥º', 'ğŸ¤©', 'ğŸ˜±', 'ğŸ˜´', 'ğŸ¥´', 'ğŸ¤§', 'ğŸ¤ '],
            fruits: ['ğŸ“', 'ğŸ‰', 'ğŸ', 'ğŸŠ', 'ğŸ‡', 'ğŸ', 'ğŸ¥', 'ğŸ¥­', 'ğŸ‘', 'ğŸ’', 'ğŸŒ', 'ğŸ¥¥', 'ğŸ¥‘', 'ğŸˆ', 'ğŸ«', 'ğŸ', 'ğŸ‹', 'ğŸŒ¶ï¸', 'ğŸŒ½', 'ğŸ¥•'],
            animals: ['ğŸ¦Š', 'ğŸ»', 'ğŸ¼', 'ğŸ¨', 'ğŸ¯', 'ğŸ¦', 'ğŸ®', 'ğŸ·', 'ğŸ¸', 'ğŸ™', 'ğŸµ', 'ğŸ¦„', 'ğŸ”', 'ğŸ§', 'ğŸ¦‰', 'ğŸ¦‹', 'ğŸŒ', 'ğŸ', 'ğŸ¢', 'ğŸ¬'],
            objects: ['âš½', 'ğŸ€', 'ğŸˆ', 'ğŸ±', 'ğŸ', 'ğŸˆ', 'ğŸ‰', 'ğŸ„', 'ğŸ’¡', 'ğŸ’»', 'ğŸ“±', 'â°', 'ğŸ’', 'ğŸ””', 'ğŸ”‘', 'ğŸ‘‘', 'â˜‚ï¸', 'ğŸ¨', 'ğŸ“š', 'âœï¸'],
            sweets: ['ğŸ°', 'ğŸ§', 'ğŸ©', 'ğŸª', 'ğŸ¬', 'ğŸ­', 'ğŸ«', 'ğŸ¦', 'ğŸ§', 'ğŸ®', 'ğŸ¯', 'ğŸ¥§', 'ğŸ¥¨', 'ğŸ§‡', 'ğŸ¡', 'ğŸ¥®', 'ğŸ¥ ', 'ğŸ¥', 'ğŸ§‹', 'ğŸ¥¤'],
            vehicles: ['ğŸš—', 'ğŸš•', 'ğŸš™', 'ğŸšŒ', 'ğŸš', 'ğŸï¸', 'ğŸš“', 'ğŸš‘', 'ğŸš’', 'ğŸš', 'ğŸšš', 'ğŸš›', 'ğŸšœ', 'ğŸ›µ', 'ğŸš²', 'âœˆï¸', 'ğŸš€', 'ğŸ›¸', 'ğŸš', 'â›µï¸'],
            music: ['ğŸ¸', 'ğŸº', 'ğŸ·', 'ğŸ»', 'ğŸ¹', 'ğŸ¥', 'ğŸ¤', 'ğŸ§', 'ğŸ¼', 'ğŸµ', 'ğŸ¶', 'ğŸª•', 'ğŸª—', 'ğŸª˜', 'ğŸ»', 'ğŸº', 'ğŸ¥', 'ğŸ·', 'ğŸ¹', 'ğŸ¤'],
            weather: ['â˜€ï¸', 'ğŸŒ™', 'â­', 'â˜ï¸', 'â›…', 'â›ˆï¸', 'ğŸŒ¤ï¸', 'ğŸŒ¥ï¸', 'ğŸŒ¦ï¸', 'ğŸŒ§ï¸', 'ğŸŒ¨ï¸', 'ğŸŒ©ï¸', 'ğŸŒªï¸', 'ğŸŒ«ï¸', 'ğŸŒ¬ï¸', 'ğŸŒˆ', 'â„ï¸', 'â˜ƒï¸', 'â›„', 'ğŸŒ¡ï¸'],
            sports: ['âš½', 'ğŸ€', 'ğŸˆ', 'âš¾', 'ğŸ¥', 'ğŸ', 'ğŸ‰', 'ğŸ±', 'ğŸ¥', 'ğŸ¸', 'ğŸ’', 'ğŸ‘', 'ğŸ¥', 'ğŸ', 'ğŸ¥…', 'â›³', 'ğŸª', 'ğŸ¹', 'ğŸ£', 'ğŸ¥Š']
        };
        const ALL_ICONS_COMBINED = [...new Set([...EMOJI_SETS.faces, ...EMOJI_SETS.fruits, ...EMOJI_SETS.animals, ...EMOJI_SETS.objects, ...EMOJI_SETS.sweets, ...EMOJI_SETS.vehicles, ...EMOJI_SETS.music, ...EMOJI_SETS.weather, ...EMOJI_SETS.sports])];


        // --- Level Definitions ---
        const levels = [
            { levelNumber: 1, levelName: "æ–°æ‰‹ä¸Šè·¯", timeLimit: 120, boardRows: 6, boardCols: 8, tileTypesCount: 8, maxErrors: 10, starsEarned: 0,
              theme: { name: "å…¥é—¨", backgroundColor: 'linear-gradient(135deg, #FFB6C1 0%, #89CFF0 100%)', iconSet: EMOJI_SETS.faces, bgmTheme: "å…¥é—¨" } },
            { levelNumber: 2, levelName: "æ°´æœä¹å›­", timeLimit: 150, boardRows: 8, boardCols: 10, tileTypesCount: 10, maxErrors: 8, starsEarned: 0,
              theme: { name: "æ°´æœ", backgroundColor: 'linear-gradient(135deg, #A8E063 0%, #56AB2F 100%)', iconSet: EMOJI_SETS.fruits, bgmTheme: "æ°´æœ" } },
            { levelNumber: 3, levelName: "åŠ¨ç‰©æ€»åŠ¨å‘˜", timeLimit: 180, boardRows: 8, boardCols: 12, tileTypesCount: 12, maxErrors: 7, starsEarned: 0,
              theme: { name: "åŠ¨ç‰©", backgroundColor: 'linear-gradient(135deg, #F3A183 0%, #EC6F66 100%)', iconSet: EMOJI_SETS.animals, bgmTheme: "åŠ¨ç‰©" } },
            { levelNumber: 4, levelName: "ç‰©å“å¤§æŒ‘æˆ˜", timeLimit: 200, boardRows: 10, boardCols: 12, tileTypesCount: 15, maxErrors: 6, starsEarned: 0,
              theme: { name: "ç‰©å“", backgroundColor: 'linear-gradient(135deg, #74EBD5 0%, #9FACE6 100%)', iconSet: EMOJI_SETS.objects, bgmTheme: "ç‰©å“" } },
            { levelNumber: 5, levelName: "ç”œç‚¹æ—¶å…‰", timeLimit: 210, boardRows: 10, boardCols: 14, tileTypesCount: 16, maxErrors: 5, starsEarned: 0,
              theme: { name: "ç”œç‚¹", backgroundColor: 'linear-gradient(135deg, #FFC0CB 0%, #FFDAB9 100%)', iconSet: EMOJI_SETS.sweets, bgmTheme: "ç”œç‚¹" } },
            { levelNumber: 6, levelName: "äº¤é€šæ¢çº½", timeLimit: 220, boardRows: 10, boardCols: 14, tileTypesCount: 18, maxErrors: 5, starsEarned: 0,
              theme: { name: "äº¤é€š", backgroundColor: 'linear-gradient(135deg, #A0A0A0 0%, #505050 100%)', iconSet: EMOJI_SETS.vehicles, bgmTheme: "äº¤é€š" } },
            { levelNumber: 7, levelName: "éŸ³ä¹ç››ä¼š", timeLimit: 230, boardRows: 12, boardCols: 14, tileTypesCount: 18, maxErrors: 4, starsEarned: 0,
              theme: { name: "éŸ³ä¹", backgroundColor: 'linear-gradient(135deg, #D2B4DE 0%, #A569BD 100%)', iconSet: EMOJI_SETS.music, bgmTheme: "éŸ³ä¹" } },
            { levelNumber: 8, levelName: "å¤©æ°”æ’­æŠ¥", timeLimit: 240, boardRows: 12, boardCols: 16, tileTypesCount: 20, maxErrors: 4, starsEarned: 0,
              theme: { name: "å¤©æ°”", backgroundColor: 'linear-gradient(135deg, #87CEEB 0%, #4682B4 100%)', iconSet: EMOJI_SETS.weather, bgmTheme: "å¤©æ°”" } },
            { levelNumber: 9, levelName: "è¿åŠ¨å¥å°†", timeLimit: 250, boardRows: 12, boardCols: 16, tileTypesCount: 20, maxErrors: 3, starsEarned: 0,
              theme: { name: "è¿åŠ¨", backgroundColor: 'linear-gradient(135deg, #FF8C00 0%, #FF4500 100%)', iconSet: EMOJI_SETS.sports, bgmTheme: "è¿åŠ¨" } },
            { levelNumber: 10, levelName: "ç»ˆææ··æ­", timeLimit: 280, boardRows: 12, boardCols: 18, tileTypesCount: 22, maxErrors: 3, starsEarned: 0,
              theme: { name: "å¤§å¸ˆ", backgroundColor: 'linear-gradient(135deg, #6a11cb 0%, #2575fc 100%)', iconSet: ALL_ICONS_COMBINED, bgmTheme: "å¤§å¸ˆ" } }
        ];
        let currentLevelIndex = 0;
        let maxUnlockedLevel = 1;

        // Game Parameters (ä¼šè¢« updateGameParametersAndStyles åŠ¨æ€ä¿®æ”¹)
        let gameParams = {
            tileWidth: 48, tileHeight: 48, gap: 5, boardPadding: 10, fontSize: 26,
            boardRowsLogical: levels[0].boardRows,
            boardColsLogical: levels[0].boardCols,
            boardRowsPhysical: levels[0].boardRows + 2,
            boardColsPhysical: levels[0].boardCols + 2,
            timeLimit: levels[0].timeLimit,
            tileTypesCount: levels[0].tileTypesCount,
            totalLogicalTiles: levels[0].boardRows * levels[0].boardCols,
            currentIconSet: levels[0].theme.iconSet,
            maxErrorsAllowed: levels[0].maxErrors
        };

        const INITIAL_HINTS = 3;

        // Game State
        let gameBoardArray = [];
        let score = 0;
        let timeLeft = gameParams.timeLimit;
        let timerInterval = null;
        let firstSelectedTile = null;
        let remainingTiles = 0;
        let gameActive = false;
        let pathClearTimeout = null;
        let autoShuffleAttempts = 0;
        const MAX_AUTO_SHUFFLE_ATTEMPTS = 1;
        let hintCount = INITIAL_HINTS;
        let hintHighlightTimeout = null;
        let audioInitialized = false;
        let connectionErrors = 0;
        let currentBGMLoop = null;


        // --- Local Storage ---
        const STORAGE_KEY_MAX_LEVEL = 'lianliankan_maxUnlockedLevel_v8'; // Incremented version
        const STORAGE_KEY_LEVELS_DATA = 'lianliankan_levelsData_v8';

        function saveProgress() {
            try {
                localStorage.setItem(STORAGE_KEY_MAX_LEVEL, maxUnlockedLevel.toString());
                localStorage.setItem(STORAGE_KEY_LEVELS_DATA, JSON.stringify(levels.map(l => ({ levelNumber: l.levelNumber, starsEarned: l.starsEarned }))));
            } catch (e) {
                console.error("Failed to save progress to localStorage:", e);
            }
        }
        function loadProgress() {
             try {
                const savedMaxLevel = localStorage.getItem(STORAGE_KEY_MAX_LEVEL);
                if (savedMaxLevel !== null) {
                    maxUnlockedLevel = parseInt(savedMaxLevel, 10);
                } else {
                    maxUnlockedLevel = 1;
                }
                const savedLevelsDataString = localStorage.getItem(STORAGE_KEY_LEVELS_DATA);
                if (savedLevelsDataString) {
                    const parsedSavedLevels = JSON.parse(savedLevelsDataString);
                    if (Array.isArray(parsedSavedLevels)) {
                        levels.forEach((currentLevelInCode) => {
                            const savedLevelData = parsedSavedLevels.find(sl => sl.levelNumber === currentLevelInCode.levelNumber);
                            if (savedLevelData && typeof savedLevelData.starsEarned !== 'undefined') {
                                currentLevelInCode.starsEarned = savedLevelData.starsEarned;
                            } else {
                                currentLevelInCode.starsEarned = currentLevelInCode.starsEarned || 0;
                            }
                        });
                    }
                } else {
                    levels.forEach(level => level.starsEarned = level.starsEarned || 0);
                }
            } catch (e) {
                console.error("Failed to load progress from localStorage:", e);
                maxUnlockedLevel = 1;
                levels.forEach(level => level.starsEarned = 0);
            }
        }


        // --- Audio Setup (Tone.js) ---
        let sounds = {};
        function initializeAudio() { /* ... (same as previous version, kept for brevity) ... */
            if (audioInitialized) return;
            sounds.click = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination();
            sounds.match1 = new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.05, release: 0.2 }, volume: -12 }).toDestination();
            sounds.match2 = new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.05, release: 0.2 }, volume: -12 }).toDestination();
            sounds.error = new Tone.Synth({ oscillator: { type: "square" }, envelope: { attack: 0.01, decay: 0.15, sustain: 0, release: 0.1 } }).toDestination();
            sounds.win = new Tone.PolySynth({ polyphony: 4, voice: Tone.Synth, options: { envelope: { attack: 0.05, decay: 0.5, sustain: 0.1, release: 1 } } }).toDestination();
            sounds.gameOver = new Tone.Synth({ oscillator: { type: "sawtooth" }, envelope: { attack: 0.1, decay: 0.8, sustain: 0, release: 0.5 } }).toDestination();
            sounds.buttonClick = new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 2, envelope: { attack: 0.001, decay: 0.1, sustain: 0 } }).toDestination();
            sounds.bgmSynth = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.1, decay: 0.3, sustain: 0.1, release: 1 }, volume: -25 }).toDestination();
            const filter = new Tone.Filter(800, "lowpass").toDestination();
            sounds.bgmSynth.connect(filter);
            sounds.bgmLoops = {
                "å…¥é—¨": new Tone.Loop(time => { sounds.bgmSynth.triggerAttackRelease("C4", "2n", time); sounds.bgmSynth.triggerAttackRelease("G4", "2n", time + Tone.Time("2n").toSeconds()); }, "1m"),
                "æ°´æœ": new Tone.Loop(time => { sounds.bgmSynth.triggerAttackRelease("D4", "4n", time); sounds.bgmSynth.triggerAttackRelease("A4", "4n", time + 0.5); sounds.bgmSynth.triggerAttackRelease("F#4", "4n", time + 1); }, "2m"),
                "åŠ¨ç‰©": new Tone.Loop(time => { sounds.bgmSynth.triggerAttackRelease("E4", "2n", time); sounds.bgmSynth.triggerAttackRelease("B3", "2n", time + 1); }, "2m"),
                "ç‰©å“": new Tone.Loop(time => { sounds.bgmSynth.triggerAttackRelease("F4", "1m", time); }, "1m"),
                "ç”œç‚¹": new Tone.Loop(time => { sounds.bgmSynth.triggerAttackRelease("G4", "4n", time); sounds.bgmSynth.triggerAttackRelease("C5", "4n", time + 0.5); sounds.bgmSynth.triggerAttackRelease("E5", "4n", time + 1); }, "2m"),
                "äº¤é€š": new Tone.Loop(time => { sounds.bgmSynth.triggerAttackRelease("A3", "2n", time); sounds.bgmSynth.triggerAttackRelease("E4", "2n", time + 1); }, "2m"),
                "éŸ³ä¹": new Tone.Loop(time => { const notes = ["C4", "D4", "E4", "F4", "G4", "A4", "B4", "C5"]; const note = notes[Math.floor(Math.random() * notes.length)]; sounds.bgmSynth.triggerAttackRelease(note, "4n", time); }, "1n"),
                "å¤©æ°”": new Tone.Loop(time => { sounds.bgmSynth.triggerAttackRelease("C4", "1m", time, 0.8); }, "1m"),
                "è¿åŠ¨": new Tone.Loop(time => { sounds.bgmSynth.triggerAttackRelease("D4", "8n", time); sounds.bgmSynth.triggerAttackRelease("G4", "8n", time + 0.25); sounds.bgmSynth.triggerAttackRelease("A4", "8n", time + 0.5); }, "1n"),
                "å¤§å¸ˆ": new Tone.Loop(time => { sounds.bgmSynth.triggerAttackRelease("C4", "1n", time); sounds.bgmSynth.triggerAttackRelease("F4", "1n", time + 1); sounds.bgmSynth.triggerAttackRelease("Bb3", "1n", time + 2); sounds.bgmSynth.triggerAttackRelease("Eb4", "1n", time + 3); }, "4m")
            };
            audioInitialized = true;
        }
        async function ensureAudioStarted() { /* ... (same as previous version) ... */
            if (typeof Tone === 'undefined' || Tone === null) { return false; }
            if (Tone.context.state !== 'running') { try { await Tone.start(); } catch (e) { return false; } }
            if (!audioInitialized) { initializeAudio(); }
            return true;
         }
        async function playSound(soundType) { /* ... (same as previous version) ... */
            const audioIsReady = await ensureAudioStarted();
            if (!audioIsReady || !audioInitialized || typeof Tone === 'undefined' || (soundType === 'match' && (!sounds.match1 || !sounds.match2)) || (soundType !== 'match' && !sounds[soundType])) { return; }
            const now = Tone.now(); try { switch(soundType) { case 'click': sounds.click.triggerAttackRelease("C5", "8n", now); break; case 'match': sounds.match1.triggerAttackRelease("E5", "8n", now); sounds.match2.triggerAttackRelease("G5", "8n", now + 0.15); break; case 'error': sounds.error.triggerAttackRelease("A2", "8n", now); break; case 'win': sounds.win.triggerAttackRelease(["C4", "E4", "G4", "C5"], "0.5n", now); sounds.win.triggerAttackRelease(["E4", "G4", "B4", "E5"], "0.5n", now + 0.4); sounds.win.triggerAttackRelease(["G4", "B4", "D5", "G5"], "0.5n", now + 0.8); break; case 'gameOver': sounds.gameOver.triggerAttackRelease("F#3", "1n", now); break; case 'buttonClick': sounds.buttonClick.triggerAttackRelease("C3", "16n", now); break; } } catch (e) { console.error("Error playing sound:", e); }
        }
        function playBGM(themeName) { /* ... (same as previous version) ... */
            if (!audioInitialized || typeof Tone === 'undefined') return; stopBGM(); if (sounds.bgmLoops[themeName]) { currentBGMLoop = sounds.bgmLoops[themeName]; currentBGMLoop.start(0).stop(gameParams.timeLimit + 2); Tone.Transport.start(); } else { if (sounds.bgmLoops["å…¥é—¨"]) { currentBGMLoop = sounds.bgmLoops["å…¥é—¨"]; currentBGMLoop.start(0).stop(gameParams.timeLimit + 2); Tone.Transport.start(); } }
        }
        function stopBGM() { /* ... (same as previous version) ... */
            if (typeof Tone === 'undefined') return; if (currentBGMLoop) { currentBGMLoop.stop(0); } Tone.Transport.stop(); Tone.Transport.cancel(); currentBGMLoop = null;
        }

        // --- Responsive Parameter Update ---
        function updateGameParametersAndStyles() {
            const iw = window.innerWidth;
            const gameContainerElement = gameWrapper.querySelector('.game-container');
            let effectiveBoardContainerWidth;

            if (gameWrapper.style.display !== 'none' && gameContainerElement && gameContainerElement.offsetWidth > 0) {
                effectiveBoardContainerWidth = gameContainerElement.clientWidth;
            } else {
                const typicalGameContainerPadding = (iw < 640 ? 10 : (iw < 768 ? 20 : 25)); // Updated padding estimates
                effectiveBoardContainerWidth = iw * 0.95 - (2 * typicalGameContainerPadding);
            }

            const currentBoardColsLogical = gameParams.boardColsLogical;
            let currentGap, currentBoardPaddingForBoardItself;

            if (iw < 480) { // å°å‹ç§»åŠ¨è®¾å¤‡
                currentGap = 2;
                currentBoardPaddingForBoardItself = 2; // æ£‹ç›˜è‡ªèº«å†…è¾¹è·å¯ä»¥æ›´å°
            } else if (iw < 768) { // ä¸­å‹è®¾å¤‡
                currentGap = 3;
                currentBoardPaddingForBoardItself = 4;
            } else { // å¤§å‹è®¾å¤‡
                currentGap = 4;
                currentBoardPaddingForBoardItself = 5;
            }
            gameParams.gap = currentGap;

            const boardBorderThickness = 2;
            const spaceForBoardContentAndItsPadding = effectiveBoardContainerWidth - (2 * boardBorderThickness);
            const spaceForTilesAndGaps = spaceForBoardContentAndItsPadding - (2 * currentBoardPaddingForBoardItself);
            let calculatedTileWidth = (spaceForTilesAndGaps - (currentBoardColsLogical - 1) * currentGap) / currentBoardColsLogical;

            gameParams.tileWidth = Math.max(18, Math.floor(calculatedTileWidth)); // æœ€å°å›¾å—å®½åº¦ç•¥å¾®å¢å¤§åˆ°18px
            gameParams.tileHeight = gameParams.tileWidth;

            // --- OPTIMIZATION 2: Tile Icon Size ---
            // å¢å¤§è¡¨æƒ…ç¬¦å·ç›¸å¯¹äºå›¾å—çš„æ¯”ä¾‹ï¼Œå¹¶ä¿è¯æœ€å°10px
            gameParams.fontSize = Math.max(10, Math.floor(gameParams.tileWidth * 0.62)); // æ¯”ä¾‹ä»0.55è°ƒæ•´åˆ°0.62

            document.documentElement.style.setProperty('--tile-font-size', gameParams.fontSize + 'px');
            gameParams.boardPadding = currentBoardPaddingForBoardItself;
            gameParams.boardRowsPhysical = gameParams.boardRowsLogical + 2;
            gameParams.boardColsPhysical = gameParams.boardColsLogical + 2;
        }


        // --- Helper Functions ---
        const CUTE_SUCCESS_MESSAGES = ["å¤ªæ£’å•¦ï¼ğŸ‰", "çœŸå‰å®³ï¼âœ¨", "å¥½æ ·çš„ï¼ğŸ¥³", "æ¼‚äº®ï¼ğŸŒŸ", "å®Œç¾ï¼ğŸ’–"];
        function showMessage(message, type = 'success', duration = 2000) { /* ... (same as previous version) ... */
            let displayMessage = message; if (type === 'success' && message === "æˆåŠŸæ¶ˆé™¤!") { displayMessage = CUTE_SUCCESS_MESSAGES[Math.floor(Math.random() * CUTE_SUCCESS_MESSAGES.length)]; } messageBox.textContent = displayMessage; messageBox.className = 'message-box'; messageBox.classList.add(type); if (messageBox.style.display === 'none') { messageBox.style.display = 'block'; requestAnimationFrame(() => { messageBox.classList.add('show'); }); } else { messageBox.classList.add('show'); } const effectiveDuration = (type === 'win' || type === 'gameover' || message.includes("è‡ªåŠ¨æ´—ç‰Œ") || message.includes("æç¤º")) ? Math.max(duration, 3000) : duration; if (messageBox.hideTimeout) clearTimeout(messageBox.hideTimeout); messageBox.hideTimeout = setTimeout(() => { messageBox.classList.remove('show'); setTimeout(() => { if (!messageBox.classList.contains('show')) { messageBox.style.display = 'none'; } }, 350); }, effectiveDuration);
        }
        function shuffleArray(array) { /* ... (same as previous version) ... */
             for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; }
        }
        function formatTime(seconds) { /* ... (same as previous version) ... */
            const minutes = Math.floor(seconds / 60); const rs = seconds % 60; return `${minutes < 10 ? '0' : ''}${minutes}:${rs < 10 ? '0' : ''}${rs}`;
        }
        function updateHintsDisplay() { hintsDisplay.textContent = `æç¤º: ${hintCount}`; }
        function updateErrorsDisplay() { errorsDisplay.textContent = `é”™è¯¯: ${connectionErrors}/${gameParams.maxErrorsAllowed}`; }


        // --- Canvas and Path Drawing ---
        function setupCanvas() { /* ... (same as previous version, uses updated gameParams) ... */
            const boardElementWidth = gameParams.boardColsLogical * gameParams.tileWidth + (gameParams.boardColsLogical - 1) * gameParams.gap + 2 * gameParams.boardPadding; const boardElementHeight = gameParams.boardRowsLogical * gameParams.tileHeight + (gameParams.boardRowsLogical - 1) * gameParams.gap + 2 * gameParams.boardPadding; pathCanvas.width = boardElementWidth; pathCanvas.height = boardElementHeight; pathCanvas.style.top = gameBoardElement.offsetTop + 'px'; pathCanvas.style.left = gameBoardElement.offsetLeft + 'px'; clearPathCanvas();
        }
        function clearPathCanvas() { pathCtx.clearRect(0, 0, pathCanvas.width, pathCanvas.height); }
        function getTileCenter(r_array_idx, c_array_idx) { /* ... (same as previous version) ... */
            let x, y; if (c_array_idx === 0) { x = gameParams.boardPadding / 2 - gameParams.gap / 2; } else if (c_array_idx === gameParams.boardColsPhysical - 1) { x = gameParams.boardPadding + gameParams.boardColsLogical * gameParams.tileWidth + (gameParams.boardColsLogical -1) * gameParams.gap + gameParams.gap/2 + gameParams.boardPadding/2; } else { x = gameParams.boardPadding + (c_array_idx - 1) * (gameParams.tileWidth + gameParams.gap) + gameParams.tileWidth / 2; } if (r_array_idx === 0) { y = gameParams.boardPadding / 2 - gameParams.gap / 2; } else if (r_array_idx === gameParams.boardRowsPhysical - 1) { y = gameParams.boardPadding + gameParams.boardRowsLogical * gameParams.tileHeight + (gameParams.boardRowsLogical -1) * gameParams.gap + gameParams.gap/2 + gameParams.boardPadding/2; } else { y = gameParams.boardPadding + (r_array_idx - 1) * (gameParams.tileHeight + gameParams.gap) + gameParams.tileHeight / 2; } return { x, y };
        }
        function drawConnectionPath(pathPoints, color = 'var(--cute-blue)', duration = 500) { /* ... (same as previous version) ... */
            if (!pathPoints || pathPoints.length < 2) return; clearPathCanvas(); pathCtx.beginPath(); pathCtx.strokeStyle = color; pathCtx.lineWidth = Math.max(3, gameParams.tileWidth / 12); pathCtx.lineCap = 'round'; pathCtx.lineJoin = 'round'; const firstPointCoords = getTileCenter(pathPoints[0].r, pathPoints[0].c); pathCtx.moveTo(firstPointCoords.x, firstPointCoords.y); for (let i = 1; i < pathPoints.length; i++) { const pointCoords = getTileCenter(pathPoints[i].r, pathPoints[i].c); pathCtx.lineTo(pointCoords.x, pointCoords.y); } pathCtx.stroke(); if (pathClearTimeout) clearTimeout(pathClearTimeout); pathClearTimeout = setTimeout(clearPathCanvas, duration);
        }

        // --- Timer Functions ---
        function startTimer() { /* ... (same as previous version) ... */
            clearInterval(timerInterval); timeLeft = gameParams.timeLimit; timerDisplay.textContent = `æ—¶é—´: ${formatTime(timeLeft)}`; gameActive = true; timerInterval = setInterval(() => { timeLeft--; timerDisplay.textContent = `æ—¶é—´: ${formatTime(timeLeft)}`; if (timeLeft < 0) { timeLeft = 0; timerDisplay.textContent = `æ—¶é—´: ${formatTime(timeLeft)}`; handleGameOver("time"); } }, 1000);
        }

        // --- Pathfinding ---
        function isPathClear(r1,c1,r2,c2){if(r1===r2){for(let i=Math.min(c1,c2)+1;i<Math.max(c1,c2);i++)if(gameBoardArray[r1][i]!==null)return false;return true}if(c1===c2){for(let i=Math.min(r1,r2)+1;i<Math.max(r1,r2);i++)if(gameBoardArray[i][c1]!==null)return false;return true}return false}
        function checkZeroTurn(t1,t2){if(t1.r!==t2.r&&t1.c!==t2.c)return null;if(isPathClear(t1.r,t1.c,t2.r,t2.c))return[{r:t1.r,c:t1.c},{r:t2.r,c:t2.c}];return null}
        function checkOneTurn(t1,t2){const p1c={r:t1.r,c:t2.c},p2c={r:t2.r,c:t1.c};if(gameBoardArray[p1c.r][p1c.c]===null&&isPathClear(t1.r,t1.c,p1c.r,p1c.c)&&isPathClear(p1c.r,p1c.c,t2.r,t2.c))return[{r:t1.r,c:t1.c},p1c,{r:t2.r,c:t2.c}];if(gameBoardArray[p2c.r][p2c.c]===null&&isPathClear(t1.r,t1.c,p2c.r,p2c.c)&&isPathClear(p2c.r,p2c.c,t2.r,t2.c))return[{r:t1.r,c:t1.c},p2c,{r:t2.r,c:t2.c}];return null}
        function checkTwoTurnsComprehensive(t1,t2){for(let ci=0;ci<gameParams.boardColsPhysical;ci++){const p={r:t1.r,c:ci};if((gameBoardArray[p.r][p.c]===null||(p.r===t2.r&&p.c===t2.c))&&isPathClear(t1.r,t1.c,p.r,p.c)){const op=checkOneTurn(p,t2);if(op){if(p.r===t1.r&&p.c===t1.c&&!(p.r===op[1].r&&p.c===op[1].c))continue;if(!(p.r===t2.r&&p.c===t2.c)&&gameBoardArray[p.r][p.c]!==null)continue;return[{r:t1.r,c:t1.c},...op]}}}for(let ri=0;ri<gameParams.boardRowsPhysical;ri++){const p={r:ri,c:t1.c};if((gameBoardArray[p.r][p.c]===null||(p.r===t2.r&&p.c===t2.c))&&isPathClear(t1.r,t1.c,p.r,p.c)){const op=checkOneTurn(p,t2);if(op){if(p.r===t1.r&&p.c===t1.c&&!(p.r===op[1].r&&p.c===op[1].c))continue;if(!(p.r===t2.r&&p.c===t2.c)&&gameBoardArray[p.r][p.c]!==null)continue;return[{r:t1.r,c:t1.c},...op]}}}return null}
        function canConnect(t1,t2){if(t1.r===t2.r&&t1.c===t2.c)return null;let p;p=checkZeroTurn(t1,t2);if(p)return p;p=checkOneTurn(t1,t2);if(p)return p;p=checkTwoTurnsComprehensive(t1,t2);if(p)return p;return null}

        // --- "No More Moves" & Hint Logic ---
        function findAllPossibleMoves(){ /* ... (same as previous version) ... */
            const at=[];for(let r=0;r<gameParams.boardRowsPhysical;r++)for(let c=0;c<gameParams.boardColsPhysical;c++)if(gameBoardArray[r][c]!==null){const e=gameBoardElement.querySelector(`.tile[data-row="${r}"][data-col="${c}"]`);at.push({r,c,icon:gameBoardArray[r][c],element:e})}if(at.length<2)return null;for(let i=0;i<at.length;i++)for(let j=i+1;j<at.length;j++){const t1=at[i],t2=at[j];if(t1.icon===t2.icon){const p=canConnect(t1,t2);if(p)return{tile1:t1,tile2:t2,path:p}}}return null
        }
        async function checkAndHandleNoMoreMoves(){ /* ... (same as previous version) ... */
            if(remainingTiles===0||!gameActive)return;if(firstSelectedTile&&firstSelectedTile.element){firstSelectedTile.element.classList.remove('selected');firstSelectedTile=null;clearPathCanvas()}const pm=findAllPossibleMoves();if(!pm){if(autoShuffleAttempts<MAX_AUTO_SHUFFLE_ATTEMPTS){autoShuffleAttempts++;showMessage("æ²¡æœ‰å¯æ¶ˆé™¤çš„æ–¹å—äº†ï¼Œå°è¯•è‡ªåŠ¨æ´—ç‰Œ...","info",3e3);await new Promise(r=>setTimeout(r,2e3));await shuffleBoard(!0)}else{showMessage("è‡ªåŠ¨æ´—ç‰Œåä»æ— è§£ã€‚è¯·æ‰‹åŠ¨æ´—ç‰Œæˆ–é‡æ–°å¼€å§‹ã€‚","error",5e3);playSound('error')}}else autoShuffleAttempts=0
        }
        async function provideHint(){ /* ... (same as previous version) ... */
            await ensureAudioStarted();playSound('buttonClick');if(!gameActive||remainingTiles===0){showMessage("æ¸¸æˆå°šæœªå¼€å§‹æˆ–å·²ç»“æŸã€‚","info");return}if(hintCount<=0){showMessage("æç¤ºæ¬¡æ•°å·²ç”¨å®Œ!","error");playSound('error');return}if(firstSelectedTile&&firstSelectedTile.element){firstSelectedTile.element.classList.remove('selected');firstSelectedTile=null}clearPathCanvas();if(hintHighlightTimeout)clearTimeout(hintHighlightTimeout);const m=findAllPossibleMoves();if(m&&m.tile1.element&&m.tile2.element){hintCount--;updateHintsDisplay();showMessage("æ‰¾åˆ°å¯æ¶ˆé™¤çš„æ–¹å—!","info",1500);m.tile1.element.classList.add('hint-highlight');m.tile2.element.classList.add('hint-highlight');drawConnectionPath(m.path,'#FFD700',1500);hintHighlightTimeout=setTimeout(()=>{m.tile1.element.classList.remove('hint-highlight');m.tile2.element.classList.remove('hint-highlight')},1500)}else{showMessage("å½“å‰æ²¡æœ‰å¯ç”¨çš„æç¤ºã€‚","info");playSound('error')}
        }

        // --- Modal Logic ---
        function createEndGameModal(title, message, buttons) { /* ... (same as previous version) ... */
            endGameModalOverlay.innerHTML = ''; const modalContent = document.createElement('div'); modalContent.className = 'modal-content'; const titleElement = document.createElement('h2'); titleElement.textContent = title; modalContent.appendChild(titleElement); const messageElement = document.createElement('p'); messageElement.innerHTML = message; modalContent.appendChild(messageElement); const buttonsDiv = document.createElement('div'); buttonsDiv.className = 'modal-buttons'; buttons.forEach(buttonConfig => { const button = document.createElement('button'); button.textContent = buttonConfig.text; button.className = 'btn'; if (buttonConfig.styleClass) { button.classList.add(...buttonConfig.styleClass.split(' ')); } button.onclick = async () => { const audioCanPlay = await ensureAudioStarted(); if(audioCanPlay) playSound('buttonClick'); hideEndGameModal(); buttonConfig.action(); }; buttonsDiv.appendChild(button); }); modalContent.appendChild(buttonsDiv); endGameModalOverlay.appendChild(modalContent); endGameModalOverlay.classList.add('show');
        }
        function hideEndGameModal() { /* ... (same as previous version) ... */
            endGameModalOverlay.classList.remove('show'); setTimeout(() => { if (!endGameModalOverlay.classList.contains('show')) { endGameModalOverlay.innerHTML = ''; } }, 300);
        }


        // --- Win/Clear/Fail Logic ---
        function handleGameOver(reason) { /* ... (same as previous version) ... */
            clearInterval(timerInterval); gameActive = false; let reasonText = ""; if (reason === "time") reasonText = "æ—¶é—´è€—å°½ï¼"; else if (reason === "errors") reasonText = "é”™è¯¯æ¬¡æ•°è¿‡å¤šï¼"; stopBGM(); playSound('gameOver'); gameBoardElement.style.pointerEvents = 'none'; createEndGameModal( "é—¯å…³å¤±è´¥ï¼", `å¤ªé—æ†¾äº†ï¼Œå› ä¸º${reasonText}<br>è¿™æ¬¡æ²¡æœ‰æˆåŠŸå“¦ï¼Œå†è¯•ä¸€æ¬¡å§ï¼`, [ { text: "é‡ç©æœ¬å…³", action: () => initGame(currentLevelIndex), styleClass: "bg-yellow-500" }, { text: "è¿”å›é€‰å…³", action: showLevelSelectScreen, styleClass: "bg-gray-400" } ] );
        }
        function checkWinCondition(){ /* ... (same as previous version) ... */
            if(remainingTiles === 0 && gameActive){ clearInterval(timerInterval); gameActive = false; const currentLevel = levels[currentLevelIndex]; let starsEarned = 0; const timePercentage = (timeLeft / gameParams.timeLimit) * 100; if (timePercentage > 66) starsEarned = 3; else if (timePercentage > 33) starsEarned = 2; else if (timeLeft >= 0) starsEarned = 1; levels[currentLevelIndex].starsEarned = Math.max(levels[currentLevelIndex].starsEarned || 0, starsEarned); saveProgress(); stopBGM(); playSound('win'); gameBoardElement.style.pointerEvents = 'none'; clearPathCanvas(); let modalTitle = `å¤ªæ£’äº†ï¼`; let modalMessage = `${currentLevel.levelName} å®Œæˆï¼<br>ä½ è·å¾—äº† ${'â˜…'.repeat(starsEarned)}${'â˜†'.repeat(3-starsEarned)}ï¼`; let modalButtons = []; if (currentLevelIndex + 1 < levels.length) { maxUnlockedLevel = Math.max(maxUnlockedLevel, currentLevel.levelNumber + 1); saveProgress(); modalButtons.push({ text: "ä¸‹ä¸€å…³å¡", action: () => { currentLevelIndex++; actualGameStart(); }, styleClass: "bg-green-500" }); } else { modalMessage += "<br>æ‰€æœ‰å…³å¡éƒ½å·²å®Œæˆï¼ğŸ¥³"; } modalButtons.push({ text: "é‡ç©æœ¬å…³", action: () => initGame(currentLevelIndex) }); modalButtons.push({ text: "è¿”å›é€‰å…³", action: showLevelSelectScreen, styleClass: "bg-gray-400" }); createEndGameModal(modalTitle, modalMessage, modalButtons); }
        }
        function clearTiles(t1,t2,cp){drawConnectionPath(cp);playSound('match');setTimeout(async()=>{t1.element.classList.add('cleared');t1.element.classList.remove('selected');t2.element.classList.add('cleared');t2.element.classList.remove('selected');gameBoardArray[t1.r][t1.c]=null;gameBoardArray[t2.r][t2.c]=null;score+=10;remainingTiles-=2;scoreDisplay.textContent=`å¾—åˆ†: ${score}`; showMessage("æˆåŠŸæ¶ˆé™¤!", "success", 1000); if(remainingTiles>0&&gameActive){await new Promise(r=>setTimeout(r,50));await checkAndHandleNoMoreMoves()}setTimeout(checkWinConditionï¼Œ100)}ï¼Œ100)}

        // --- Game Setup and UI ---
        function createTilesList() { /* ... (same as previous version) ... */
            const numTileTypes = gameParams.tileTypesCount; const totalTilesForLevel = gameParams.totalLogicalTiles; const currentIconSet = gameParams.currentIconSet; if (totalTilesForLevel % 2 !== 0) { showMessage("å½“å‰å…³å¡æ£‹ç›˜å¤§å°è®¾ç½®é”™è¯¯!", "error"); return []; } if (numTileTypes > currentIconSet.length) { console.warn(`Level requires ${numTileTypes} types, but icon set only has ${currentIconSet.length}. Using all available.`); } const tiles = []; const iconsToUse = currentIconSet.slice(0, Math.min(numTileTypes, currentIconSetã€‚length)); const numPairs = totalTilesForLevel / 2; for (let i = 0; i < numPairs; i++) { const icon = iconsToUse[i % iconsToUse.length]; tiles.push(icon, icon); } shuffleArray(tiles); return tiles;
        }
        function renderBoard(){ /* ... (same as previous version, uses updated gameParams) ... */
            gameBoardElement.innerHTML=''; gameBoardElement.style.gridTemplateColumns=`repeat(${gameParams.boardColsLogical}, ${gameParams.tileWidth}px)`; gameBoardElement.style.gridTemplateRows=`repeat(${gameParams.boardRowsLogical}, ${gameParams.tileHeight}px)`; gameBoardElement.style.gap=`${gameParams.gap}px`; gameBoardElement.style.padding=`${gameParams.boardPadding}px`; gameBoardElement.style.pointerEvents='auto'; setTimeout(() => { setupCanvas(); }, 0); for(let r_arr = 1; r_arr <= gameParams.boardRowsLogical; r_arr++) { for(let c_arr = 1; c_arr <= gameParams.boardColsLogical; c_arr++) { const tileDiv=document.createElement('div'); tileDiv.dataset.row = r_arr; tileDiv.dataset.col = c_arr; const icon=gameBoardArray[r_arr][c_arr]; if(icon){tileDiv.classList.add('tile');tileDiv.textContent=icon;tileDiv.addEventListener('click',handleTileClick)} else {tileDiv.classList.add('tile','empty');} gameBoardElement.appendChild(tileDiv); } }
        }
        async function handleTileClick(e){ /* ... (same as previous version) ... */
            const clickedElement=e.currentTarget;if(!clickedElement||!clickedElement.dataset)return; const audioCanPlay = await ensureAudioStarted(); if(!gameActive)return; const rowStr=clickedElement.dataset.row, colStr=clickedElement.dataset.col;if(typeof rowStr==='undefined'||typeof colStr==='undefined')return; const r=parseInt(rowStr),c=parseInt(colStr);if(isNaN(r)||isNaN(c))return; if(!gameBoardArray[r] || typeof gameBoardArray[r][c] === 'undefined'){ console.error("Clicked tile's array data is invalid"ï¼Œ {r,c}); return; } const icon=gameBoardArray[r][c];if(!icon||clickedElement.classList.contains('cleared'))return; if(audioCanPlay)playSound('click'); const hintHighlightedTiles=gameBoardElement.querySelectorAll('.hint-highlight'); hintHighlightedTiles.forEach(ht=>ht.classList.remove('hint-highlight')); if(hintHighlightTimeout)clearTimeout(hintHighlightTimeout); if(!firstSelectedTile){firstSelectedTile={element:clickedElement,r,c,icon:icon};clickedElement.classList.add('selected')} else{ if(firstSelectedTileã€‚element===clickedElement){clickedElement.classList.remove('selected');firstSelectedTile=null} else{ const secondSelectedTile={element:clickedElement,r,c,icon:icon}; if(firstSelectedTile.icon===secondSelectedTile.icon){ const connectionPath=canConnect(firstSelectedTile,secondSelectedTile); if(connectionPath){clearTiles(firstSelectedTile,secondSelectedTile,connectionPath);firstSelectedTile=null} else{ showMessage("è¿™ä¸¤ä¸ªå›¾æ¡ˆæ— æ³•è¿æ¥!","error",1500);if(audioCanPlay)playSound('error'); connectionErrors++; updateErrorsDisplay(); if (connectionErrors >= gameParams.maxErrorsAllowed) { handleGameOver("errors"); return; } firstSelectedTile.element.classList.remove('selected');firstSelectedTile=null; } }else{ showMessage("å›¾æ¡ˆä¸åŒ¹é…!","error",1e3);if(audioCanPlay)playSound('error'); connectionErrors++; updateErrorsDisplay(); if (connectionErrors >= gameParams.maxErrorsAllowed) { handleGameOver("errors"); return; } firstSelectedTile.element.classList.remove('selected'); secondSelectedTile.element.classList.add('selected');firstSelectedTile=secondSelectedTile; } } }
        }
        async function shuffleBoard(isAutoShuffle=false){ /* ... (same as previous version) ... */
            let audioCanPlay = false; if(!isAutoShuffle){audioCanPlay = await ensureAudioStarted();if(audioCanPlay)playSound('buttonClick')} if(!gameActive&&remainingTiles>0){}else if(!gameActive&&remainingTiles===0){showMessage("æ¸¸æˆå·²é€šå…³ï¼Œæ— éœ€æ´—ç‰Œã€‚","info");return}else if(!gameActive){showMessage("æ¸¸æˆå°šæœªå¼€å§‹ï¼Œæ— éœ€æ´—ç‰Œã€‚","info");return}if(remainingTiles===0){showMessage("æ‰€æœ‰æ–¹å—éƒ½å·²æ¶ˆé™¤ï¼Œæ— éœ€æ´—ç‰Œã€‚","info");return} const currentTilesData=[];for(let r=1;r<=gameParams.boardRowsLogical;r++)for(let c=1;c<=gameParams.boardColsLogical;c++)if(gameBoardArray[r][c]!==null)currentTilesData.push({icon:gameBoardArray[r][c],r_orig:r,c_orig:c});if(currentTilesData.length===0){if(!isAutoShuffle)showMessage("æ²¡æœ‰å¯æ´—ç‰Œçš„æ–¹å—äº†ã€‚","info");return} const iconsOnly=currentTilesData.map(t=>t.icon);shuffleArray(iconsOnly);for(let i=0;i<currentTilesData.length;i++){const originalPos=currentTilesData[i];gameBoardArray[originalPos.r_orig][originalPos.c_orig]=iconsOnly[i]} if(firstSelectedTile&&firstSelectedTile.element)firstSelectedTile.element.classList.remove('selected');firstSelectedTile=null;clearPathCanvas();renderBoard();if(!isAutoShuffle){showMessage("æ£‹ç›˜å·²æ´—ç‰Œ!","info",1500);autoShuffleAttempts=0}await new Promise(r=>setTimeout(r,50));await checkAndHandleNoMoreMoves()
        }

        let resizeTimeout;
        function handleWindowResize(){ /* ... (same as previous version) ... */
            clearTimeout(resizeTimeout);resizeTimeout=setTimeout(async()=>{ updateGameParametersAndStyles(); if(gameActive && gameWrapper.style.display !== 'none') { await initGame(currentLevelIndex); } else if (mainMenuContainer.style.display !== 'none' && !gameActive) { if (mainMenuContainer.querySelector('#levelListContainer')) { showLevelSelectScreen(); } else { showMainMenuScreen(); } } },250)
        }

        function showMainMenuScreen() { /* ... (same as previous version) ... */
            mainMenuContainer.innerHTML = ` <h1 class="main-title">å¯çˆ±è¿è¿çœ‹ä¹å›­</h1> <button id="initialStartGameButton">å¼€å§‹æŒ‘æˆ˜ï¼</button> `; mainMenuContainer.style.display = 'flex'; gameWrapper.style.display = 'none'; stopBGM(); const initialStartBtn = document.getElementById('initialStartGameButton'); if (initialStartBtn) { initialStartBtn.onclick = async () => { const audioCanPlay = await ensureAudioStarted(); if(audioCanPlay) playSound('buttonClick'); showLevelSelectScreen(); }; }
        }

        function showLevelSelectScreen() { /* ... (same as previous version) ... */
            mainMenuContainer.innerHTML = '<h1 class="level-select-title">é€‰æ‹©å…³å¡</h1>'; const levelListDiv = document.createElement('div'); levelListDiv.id = 'levelListContainer'; levels.forEach((level, index) => { const levelButton = document.createElement('button'); const stars = level.starsEarned || 0; const starIcons = `<span class="stars-display"><span class="star-filled">${'â˜…'.repeat(stars)}</span><span class="star-empty">${'â˜†'.repeat(3-stars)}</span></span>`; levelButton.innerHTML = `ç¬¬ ${level.levelNumber} å…³ <br> <span class="level-name">${levelã€‚levelName}</span> ${starIcons}`; levelButton.className = 'level-button'; if (level.levelNumber > maxUnlockedLevel) { levelButton.disabled = true; levelButton.innerHTML = `ç¬¬ ${level.levelNumber} å…³ <br> <span class="level-name">${level.levelName}</span> <span class="lock-icon">ğŸ”’</span>`; } else { levelButton.onclick = async () => { const audioCanPlay = await ensureAudioStarted(); if(audioCanPlay) playSound('buttonClick'); currentLevelIndex = index; actualGameStart(); }; } levelListDiv.appendChild(levelButton); }); mainMenuContainer.appendChild(levelListDiv); mainMenuContainer.style.display = 'flex'; gameWrapper.style.display = 'none'; stopBGM();
        }

        async function actualGameStart() { /* ... (same as previous version) ... */
            mainMenuContainer.style.display = 'none'; gameWrapper.style.display = 'flex'; await initGame(currentLevelIndex);
        }

        async function initGame(levelIdx) { /* ... (same as previous version, includes removal of levelSelectButton.textContent) ... */
            currentLevelIndex = levelIdx; const currentLevel = levels[currentLevelIndex]; gameParams.boardRowsLogical = currentLevel.boardRows; gameParams.boardColsLogical = currentLevel.boardCols; gameParams.timeLimit = currentLevel.timeLimit; gameParams.tileTypesCount = currentLevel.tileTypesCount; gameParams.totalLogicalTiles = currentLevel.boardRows * currentLevel.boardCols; gameParams.currentIconSet = currentLevel.theme.iconSet; gameParams.maxErrorsAllowed = currentLevel.maxErrors; gameParams.boardRowsPhysical = currentLevel.boardRows + 2; gameParams.boardColsPhysical = currentLevel.boardCols + 2; document.body.style.background = currentLevel.theme.backgroundColor; levelTitleElement.textContent = `ç¬¬ ${currentLevel.levelNumber} å…³: ${currentLevel.levelName}`; levelSelectButton.style.backgroundColor = "var(--cute-purple)"; levelSelectButton.style.color = "var(--text-dark)"; levelSelectButton.style.display = 'flex'; levelSelectButton.onclick = async () => { const audioCanPlay = await ensureAudioStarted(); if(audioCanPlay) playSound('buttonClick'); gameActive = false; clearInterval(timerInterval); stopBGM(); showLevelSelectScreen(); }; if (controls) { const existingNextLevelButton = controls.querySelector('.next-level-btn'); if (existingNextLevelButton) { existingNextLevelButton.remove(); } } updateGameParametersAndStyles(); clearInterval(timerInterval); if(pathClearTimeout) clearTimeout(pathClearTimeout); if(hintHighlightTimeout) clearTimeout(hintHighlightTimeout); firstSelectedTile = null; gameBoardArray = Array(gameParamsã€‚boardRowsPhysical).fill(null).map(() => Array(gameParams.boardColsPhysical).fill(null)); remainingTiles = gameParams.totalLogicalTiles; autoShuffleAttempts = 0; hintCount = INITIAL_HINTS; connectionErrors = 0; updateHintsDisplay(); updateErrorsDisplay(); const tilesList = createTilesList(); if (tilesList.length === 0 && gameParams.totalLogicalTiles > 0) { return; } let tileIdx = 0; for (let r = 1; r <= gameParams.boardRowsLogical; r++) { for (let c = 1; c <= gameParams.boardColsLogical; c++) { if (tileIdx < tilesList.length) gameBoardArray[r][c] = tilesList[tileIdx++]; } } renderBoard(); score = 0; scoreDisplay.textContent = `å¾—åˆ†: ${score}`; await ensureAudioStarted(); playBGM(currentLevel.theme.name); startTimer(); await new Promise(resolve => setTimeout(resolve, 100)); await checkAndHandleNoMoreMoves(); gameActive = true;
        }

        restartButton.addEventListener('click', async () => { /* ... (same as previous version) ... */
            const audioCanPlay = await ensureAudioStarted(); if(audioCanPlay) playSound('buttonClick'); stopBGM(); initGame(currentLevelIndex);
        });
        shuffleButton.addEventListener('click', () => shuffleBoard(false));
        hintButton.addEventListener('click', provideHint);

        document.body.addEventListener('click', ensureAudioStarted, { once: true });
        window.addEventListener('resize', handleWindowResize);

        window.onload = () => { /* ... (same as previous version) ... */
            loadProgress(); updateGameParametersAndStyles(); mainMenuContainer.style.display = 'flex'; gameWrapper.style.display = 'none'; showMainMenuScreen();
        };
    </script>
</body>
</html>
